---
title: 设计模式--观察者模式
date: 2019-09-01 14:26:33
categories: 设计模式
tags:
	- 观察者模式
---
## 定义
**观察者模式**定义了对象之间的一对多依赖，这样一来，当对象改变状态时，它的所有依赖者都会收到通知并自动更新。

## 角色
* 抽象主题（Subject）：它把所有观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
* 具体主题（Concrete Subject）:将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。
* 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
* 具体观察者（Concrete Observer）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。

## 类图
![Observer UML](/images/design-patterns/Observer%20UML.png)

## 实现
```java
public class ConcreteObservable extends Observable {

    public void change() {
        super.setChanged();
        super.notifyObservers();
    }
}

public class ConcreteObserver implements Observer {

    @Override
    public void update(Observable o, Object arg) {
        System.out.println("observable changed：" + arg);
    }
}

public class Client {

    public static void main(String[] args) {
        ConcreteObservable observable = new ConcreteObservable();
        observable.addObserver(new ConcreteObserver());
        observable.change();
    }
}
```

## 优缺点
### 优点
* 观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖于具体

### 缺点
* 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间
* 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环依赖，可能导致系统崩溃。
* 观察者模式没有相应的机制让观察者知道所观察的目标对象时怎么发生变化的，而仅仅只是知道观察者发生了变化。

## 适用场景
* 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度
* 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象...，可以使用观察者模式创建一种链式触发机制

## 模式应用
### Java Swing

### Spring事件发布
Spring事件发布使用的是观察者模式的另一种形态：[监听器模式](https://cdrcool.github.io/2019/09/01/设计模式--监听器模式/)，它们都是基于事件驱动模型。