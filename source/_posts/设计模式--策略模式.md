---
title: 设计模式--策略模式
date: 2019-08-31 14:39:20
categories: 设计模式
tags:
	- 策略模式
---
## 定义
**策略模式**定义了算法簇，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

## 角色
* 抽象策略类（Strategy）：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口。Context使用这个接口调用不同的算法，一般使用接口或抽象类实现。
* 具体策略类（Concrete Strategy）：实现了Strategy定义的接口，提供具体的算法实现。
* 应用场景（Context）：内部维护一个Strategy的实例，负责动态设置运行时Strategy具体的实现算法。

## 类图
![Strategy UML](/images/design-patterns/Strategy UML.png)

## 实现
```java
public interface Strategy {

    void operation();
}

public class StrategyA implements Strategy {

    public void operation() {
        System.out.println("strategy A");
    }
}

public class StrategyB implements Strategy {

    public void operation() {
        System.out.println("strategy B");
    }
}

public class StrategyContext {
    private Strategy strategy;

    public StrategyContext(Strategy strategy) {
        this.strategy = strategy;
    }

    public void operation() {
        strategy.operation();
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
}
```

## 优缺点
### 优点
* 算法可以自由切换
* 避免适用多重条件判断
* 扩展性良好

### 缺点
* 策略类会增多
* 多有策略类都需要对外暴露

## 适用场景
* 一个系统需要动态地在集中算法中选择一种
* 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好适用多重条件选择语句来实现
* 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么是策略模式可以动态地让一个对象在许多行为中选择一种行为。

## 模式应用
![SecurityContextHolderStrategy UML](/images/design-patterns/SecurityContextHolderStrategy UML.png)

## 实际应用
![CacheStrategy UML](/images/design-patterns/CacheStrategy UML.png)
