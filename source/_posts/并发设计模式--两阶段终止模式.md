---
title: 并发设计模式--两阶段终止模式
date: 2019-10-21 22:55:47
categories: Java并发
---
## 概念
顾名思义，两阶段终止模式，就是将终止过程分成两个阶段，其中第一个阶段主要是线程 T1 向线程 T2 发送终止指令，而第二阶段则是线程 T2 响应终止指令。

![两阶段终止模式示意图](/images/java/两阶段终止模式示意图.png)

要透彻理解 Java 语言里的终止指令，需要从 Java 线程的状态转换过程说起，参考下图：
![线程状态转换示意图](/images/java/线程状态转换示意图.png)

由上图可知，Java 线程进入终止状态的前提是线程进入 RUNNABLE 状态，而实际上线程也可能处在休眠状态，也就是说，我们要想终止一个线程，首先要把线程的状态从休眠状态转换到 RUNNABLE 状态。如何做到呢？这个要靠 Java Thread 类提供的 interrupt() 方法，它可以将休眠状态的线程转换到 RUNNABLE 状态。
线程转换到 RUNNABLE 状态之后，我们如何再将其终止呢？RUNNABLE 状态转换到终止状态，优雅的方式是让 Java 线程自己执行完 run() 方法，所以一般我们采用的方法是设置一个标志位，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出 run() 方法。这个过程其实就是我们前面提到的第二阶段：响应终止指令。综合上面这两点，我们能总结出终止指令，其实包括两方面内容：interrupt() 方法和线程终止的标志位。

## 应用示例
### 终止采集功能
```javas
class Proxy {
    boolean started = false;
    // 采集线程
    Thread rptThread;

    // 启动采集功能
    synchronized void start() {
        // 不允许同时启动多个采集线程
        if (started) {
            return;
        }
        started = true;

        rptThread = new Thread(() -> {
            // 判断标志位
            while (!Thread.currentThread().isInterrupted()) {
                // 省略采集、回传实现
                report();
                // 每隔两秒钟采集、回传⼀次数据
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    // 重新设置线程中断状态
                    Thread.currentThread().interrupt();
                }
            }

            // 执⾏到此处说明线程⻢上终⽌
            started = false;
        });

        rptThread.start();
    }

    // 终⽌采集功能
    synchronized void stop(){
        // 将线程rptThread状态转换到RUNNABLE
        rptThread.interrupt();
    }
} 
```

需要注意的是，我们在捕获 Thread.sleep() 的中断异常之后，通过	Thread.currentThread().interrupt() 重新设置了线程的中断状态，因为 JVM 的异常处理会清除线程的中断状态。

虽然上述实现的确能够解决当前的问题，但是建议大家在实际工作中谨慎使用。原因在于我们很可能在线程的 run() 方法中调用第三方类库提供的方法，而我们没有办法保证第三方类库正确处理了线程的中断异常，例如第三方类库在捕获到 Thread.sleep() 方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以强烈建议大家设置自己的线程终止标志位，例如在下面的代码中，使用 isTerminated 作为线程终止标志位，此时无论是否正确处理了线程的中断异常，都不会影响线程优雅地终止。

```javas
class Proxy {
    // 线程终⽌标志位
    volatile boolean terminated = false;

    boolean started = false;
    // 采集线程
    Thread rptThread;

    // 启动采集功能
    synchronized void start() {
        // 不允许同时启动多个采集线程
        if (started) {
            return;
        }
        started = true;
        terminated = false;

        rptThread = new Thread(() -> {
            // 判断标志位
            while (!terminated) {
                // 省略采集、回传实现
                report();
                // 每隔两秒钟采集、回传⼀次数据
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    // 重新设置线程中断状态
                    Thread.currentThread().interrupt();
                }
            }

            // 执⾏到此处说明线程⻢上终⽌
            started = false;
        });

        rptThread.start();
    }

    // 终⽌采集功能
    synchronized void stop(){
        // 设置中断标志位
        terminated = true;

        // 中断线程rptThread
        rptThread.interrupt();
    }
} 
```

## 如何优雅地终止线程池
线程池提供了两个方法：shutdown() 和 shutdownNow()。
shutdown() 方法是一种很保守的关闭线程池的方法。线程池执行 shutdown() 后，就会拒绝接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后才最终关闭线程池。
而 shutdownNow() 方法，相对就激进一些了，线程池执行 shutdownNow() 后，会拒绝接收新的任务，同时还会中断线程池中正在执行的任务，已经进入阻塞队列的任务也被剥夺了执行的机会，不过这些被剥夺执行机会的任务会作为 shutdownNow() 方法的返回值返回。因为 shutdownNow() 方法会中断正在执行的线程，所以提交到线程池的任务，如果需要优雅地结束，就需要正确地处理线程中断。
如果提交到线程池的任务不允许取消，那就不能使用 shutdownNow() 方法终止线程池。不过，如果提交到线程池的任务允许后续以补偿的方式重新执行，也是可以使用 shutdownNow() 方法终止线程池的。

分析完 shutdown() 和 shutdownNow() 方法之后，不难发现它们实质上使用的也是两阶段终止模式，只是终止指令的范围不同而已，前者只影响阻塞队列接收任务，后者范围扩大到线程池中所有的任务。