---
title: 设计模式--状态模式
date: 2019-09-01 21:24:47
categories: 设计模式
tags:
	- 状态模式
---
## 定义
**状态模式**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

## 角色
* 环境（Context）：也称上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
* 抽象状态（State）：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
* 具体状态（Concrete State）：实现抽象状态所对应的行为。

## 类图
![State UML](/images/design-patterns/State UML.png)

## 实现
```java
/**
 * 抽象状态接口
 */
public interface State {

    /**
     * 处理请求
     */
    void handle();
}

/**
 * 具体状态
 */
public class ConcreteStateA implements State {
    private Context context;

    public ConcreteStateA(Context context) {
        this.context = context;
    }

    @Override
    public void handle() {
        System.out.println("当前状态是A");
        context.setState(new ConcreteStateB(context));
    }
}

/**
 * 具体状态B
 */
public class ConcreteStateB implements State {
    private Context context;

    public ConcreteStateB(Context context) {
        this.context = context;
    }

    @Override
    public void handle() {
        System.out.println("当前状态是B");
        context.setState(new ConcreteStateA(context));
    }
}

/**
 * 上下文
 */
public class Context {
    private State state;

    public Context() {
        // 定义上下文初始状态
        this.state = new ConcreteStateA(this);
    }

    /**
     * 请求
     */
    public void request() {
        state.handle();
    }

    /**
     * 读取状态
     *
     * @return 状态
     */
    public State getState() {
        return state;
    }

    /**
     * 设置新状态
     *
     * @param state 状态
     */
    public void setState(State state) {
        this.state = state;
    }
}
```

## 优缺点
### 优点
* 封装了转换规则
* 枚举可能的状态，在枚举状态之前需要确定状态种类
* 将所有与某个状态有关的行为封装在一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为
* 允许状态转换逻辑与状态对象合为一体，而不是某一个巨大的条件语句块
* 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数

### 缺点
* 状态模式的使用必然会增加系统类和对象的个数
* 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱
* 状态模式对**开闭原则**的支持并不太友好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应的源代码

## 适用场景
* 行为随状态改变而改变的场景
* 条件、分支语句的替代者

## 模式应用