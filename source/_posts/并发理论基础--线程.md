---
title: 并发理论基础--线程
date: 2019-10-25 16:24:03
categories: Java并发
---
## 生命周期
Java 语言中线程共有六种状态，分别是：
1. NEW（初始化状态）
2. RUNNABLE（可运行 / 运行状态）
3. BLOCKED（阻塞状态）
4. WAITING（无时限等待）
5. TIMED_WAITING（有时限等待）
6. TERMINATED（终止状态）
这看上去挺复杂的，状态类型也比较多。但其实在操作系统层面，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。所以 Java 线程的生命周期可以简化为下图：
![线程状态转换图](/images/java/线程状态转换图.png)


### RUNNABLE 与 BLOCKED 的状态转换
只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。

### RUNNABLE 与 WAITING 的状态转换
总体来说，有三种场景会触发这种转换：
1. 获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法
2. 调用无参数的 Thread.join() 方法。其中的 join() 是一种线程同步方法
3. 调用 LockSupport.park() 方法

### RUNNABLE 与 TIMED_WAITING 的状态转换
有五种场景会触发这种转换：
1. 调用带超时参数的 Thread.sleep(long millis) 方法
2. 获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法
3. 调用带超时参数的 Thread.join(long millis) 方法
4. 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法
5. 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法

### 从 NEW 到 RUNNABLE 状态
Java 刚创建出来的 Thread 对象就是 NEW 状态，NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换到 RUNNABLE 状态。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法就可以了。

### 从 RUNNABLE 到 TERMINATED 状态
线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断 run() 方法的执行，在Java 的 Thread 类里面有个 stop() 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势其实是调用 interrupt() 方法。

## 线程个数
对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。
对于 I/O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的，我们可以总结出这样一个公式：最佳线程数 =1 +（I/O 耗时 / CPU 耗时）

