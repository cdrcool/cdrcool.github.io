---
title: 设计模式--工厂模式
date: 2019-08-31 09:58:37
categories: 设计模式
tags:
	- 工厂模式
---
## 简单工厂方法
简单工厂方法不是一个设计模式，更像是一种编程习惯。

### 类图
![SimpleFactory UML](/images/design-patterns/SimpleFactory UML.png)

### 实现
```java
public class SimpleFactory {

    public static Product create(String type) {
        if ("A".equals(type)) {
            return new ProjectA();
        } else if ("B".equals(type)) {
            return new ProjectB();
        } else{
            throw new RuntimeException("不支持该类产品的创建");
        }
    }
}
```

## 工厂方法模式
### 定义
**工厂方法模式**定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

### 类图
![Factory UML](/images/design-patterns/Factory UML.png)

### 实现
```java
public interface Factory {

    Product create(String type);
}

public class FactoryA implements Factory {

    public Product create(String type) {
        if ("A".equals(type)) {
            return new ProjectA();
        } else{
            throw new RuntimeException("不支持该类产品的创建");
        }
    }
}

public class FactoryB implements Factory {

    public Product create(String type) {
        if ("B".equals(type)) {
            return new ProjectB();
        } else{
            throw new RuntimeException("不支持该类产品的创建");
        }
    }
}
```

## 抽象工厂模式
### 定义
**抽象工厂模式**提供一个接口，用于创建相关或依赖对象的家族，而不需要明确执行具体类。

### 类图
![AbstractFactory UML](/images/design-patterns/AbstractFactory UML.png)

### 实现
```java
public interface Factory {

    ProductA createProductA(String type);

    ProductB createProductB(String type);
}

public class FactoryA implements Factory {

    public ProductA createProductA(String type) {
        if ("1".equals(type)) {
            return new ProductA1();
        }   else{
            throw new RuntimeException("不支持该类产品的创建");
        }
    }

    public ProductB createProductB(String type) {
        if ("1".equals(type)) {
            return new ProductB1();
        } else{
            throw new RuntimeException("不支持该类产品的创建");
        }
    }
}

public class FactoryB implements Factory {

    public ProductA createProductA(String type) {
        if ("2".equals(type)) {
            return new ProductA2();
        }   else{
            throw new RuntimeException("不支持该类产品的创建");
        }
    }

    public ProductB createProductB(String type) {
        if ("2".equals(type)) {
            return new ProductB2();
        } else{
            throw new RuntimeException("不支持该类产品的创建");
        }
    }
}
```

## 小结
* 所有的工厂都是用来封装对象的创建
* 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象
* 工厂方法允许类将实例化延迟到子类中执行

## 模式应用
### ThreadFactory
在使用线程池时，我们可以传递`ThreadFactory`参数到`ThreadPoolExecutor`构造函数中，这样就可以方便的设置从池中获取到的线程的名字等属性。在`Executors`中提供了默认实现：
```java
public class Executors {

    ...

    static class DefaultThreadFactory implements ThreadFactory {
        private static final AtomicInteger poolNumber = new AtomicInteger(1);
        private final ThreadGroup group;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;
    
        DefaultThreadFactory() {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup() :
                                  Thread.currentThread().getThreadGroup();
            namePrefix = "pool-" +
                          poolNumber.getAndIncrement() +
                         "-thread-";
        }
    
        public Thread newThread(Runnable r) {
            Thread t = new Thread(group, r,
                                  namePrefix + threadNumber.getAndIncrement(),
                                  0);
            if (t.isDaemon())
                t.setDaemon(false);
            if (t.getPriority() != Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            return t;
        }
    }

    ...

}
```

### Spring IoC
![BeanFactory](/images/design-patterns/BeanFactory.png)

## 实际应用
根据页面类型决定使用哪一个PageDataBuilder构建页面数据。
```java
public class PageDataBuilderFactory {

    public static PageDataBuilder getPageDataBuilder(String pageType) {
        PageTypeEnum pageTypeEnum;
        try {
            pageTypeEnum = PageTypeEnum.valueOfName(pageType);
        } catch (Exception e) {
            throw new RuntimeException(String.format("尚未支持该页面类型：%s", pageType));
        }

        switch (pageTypeEnum) {
            case LIST_PAGE:
                return new ListPageDataBuilder();
            case CARD_PAGE:
                return new CardPageDataBuilder();
            default:
                throw new RuntimeException(String.format("尚未支持该页面类型：%s", pageTypeEnum.getName()));
        }
    }
}
```