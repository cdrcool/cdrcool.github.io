---
title: 设计模式--原型模式
date: 2019-08-31 22:10:59
categories: 设计模式
tags:
	- 原型模式
---
## 定义
**原型模式**允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节。工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。

## 要素
* 实现`Cloneable`接口
* 重写Object的`clone`方法

## 类图
![Prototype UML](/images/design-patterns/Prototype%20UML.png)

## 实现
```java
public abstract class Subject implements Cloneable {

    @Override
    public Subject clone() {
        Subject clone = null;
        try {
            clone = (Subject) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return clone;
    }
}

public class RealSubject extends Subject {
    
}

public class Client {

    public static void main(String[] args) {
        Subject subject = new RealSubject();
        Subject newSubject = subject.clone();
    }
}
```

## 优缺点
### 优点
* 性能提高
* 逃避构造函数的约束

### 缺点
* 必须实现`Cloneable`接口
* 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不是很容易，特别当一个类引用不支持串行化的间接对象，或者含有循环结构的时候

## 使用场景
* 资源优化场景
* 初始化需要消耗非常多的资源，包括数据、硬件资源等
* 初始化需要非常繁琐的数据准备或访问权限
* 一个对象多个修改者的场景

## 模式应用
Spring中bean默认都是单例的，用了私有全局变量，若不想影响下次注入或每次上下文获取bean，就需要用到原型模式，我们可以通过以下注解来实现：@Scope("prototype")，或@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)。

## 实际应用
实际应用中，需要注意浅拷贝带来的问题，要想深拷贝，需要对象里的对象属性也实现`Cloneable`接口，同时在`clone`方法中调用对象属性的`clone`方法。