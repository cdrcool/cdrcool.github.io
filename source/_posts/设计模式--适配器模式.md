---
title: 设计模式--适配器模式
date: 2019-08-31 16:06:01
categories: 设计模式
tags:
	- 适配器模式
---
## 定义
**适配器模式**将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

## 角色
* 目标（Target）：所期待得到的接口。
* 源（Adaptee）：需要适配的接口。
* 适配器（Adapter）：设配器模式的核心。把原接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。

## 类图
![Adaptee UML](/images/design-patterns/Adaptee UML.png)

## 实现
```java
public interface Target {

    void request();
}

public class Adaptee {

    public void specificRequest() {
        System.out.println("specific request");
    }
}

public class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        adaptee.specificRequest();
    }
}
```

## 优缺点
### 优点
* 可以让两个没有关联的类一起运行
* 提高了类的复用
* 增加了类的透明度
* 灵活性好

### 缺点
* 过多的使用适配器，会让系统非常凌乱，不易进行整体把握。比如，明明里看到的是调用A接口，其内部被适配成了B接口的实现，一个系统如果出现太多这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构
* 由于Java至多继承一个类，所以只能适配一个适配者类，而且目标类必须是抽象类

## 适用场景
* 当需要修改一个已经投产的接口时，适配器模式可以优先考虑
* 系统扩展时，需要使用一个已有或新建立的类，但是这个类不符合系统的接口
* 与二方或三方系统进行数据交互的时候，双方使用的对象不同，需要进行转换的时候

## 模式应用
## FutureTask
`FutureTask`继承自`Future`接口，它代表异步计算的结果。其源码中有以下两个构造函数：
```java
public class FutureTask<V> implements RunnableFuture<V> {

    ...

    // 构造函数1
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }
    
    // 构造函数2
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }

    ...

}
```

在构造函数2中，通过调用`Executors.callable(runnable, result)`将`Runnable`接口转换为`Callable`接口，此处即用到了适配器模式：
```java
public class Executors {

    ...

    public static <T> Callable<T> callable(Runnable task, T result) {
        if (task == null)
            throw new NullPointerException();
        return new RunnableAdapter<T>(task, result);
    }
    
    static final class RunnableAdapter<T> implements Callable<T> {
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            return result;
        }
    }

    ...

}
```


### Spring MVC
在Spring MVC中，`DispatcherServlet`通过HandlerMappings找到相应的handler，即controller（宽泛的概念controller，如Controller、HttpRequestHandler、Servlet等等），然后执行controller中相应的方法并返回ModelAndView。
由于handler的类型不同，因此调用方式就是不确定的。如果直接调用controller方法，那么调用的时候就得不断使用if else来判断是哪一种子类然后执行。如果后面要扩展controller，就得修改原来的代码，这样就违背了开闭原则。
Spring创建了一个适配器接口（`HandlerAdapter`），使得每一种handler有一种对应的适配器实现类，让适配器代替handler执行相应的方法。这样在扩展controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // Determine handler adapter for the current request.
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = "GET".equals(method);
            if (isGet || "HEAD".equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
                    return;
                }
            }

            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }

            applyDefaultViewName(processedRequest, mv);
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we're processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException("Handler dispatch failed", err);
        }
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                new NestedServletException("Handler processing failed", err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
```

![Controller UML](/images/design-patterns/Controller UML.png)
![HandlerAdapter UML](/images/design-patterns/HandlerAdapter UML.png)

### Spring IoC
在Spring IoC中，有多重方式可以自定义Bean销毁前操作，如既可以实现`DisposableBean`接口，又可以实现`DestructionAwareBeanPostProcessor`，还可以自定义`destroy`方法，那么在Spring内部要怎么统一处理呢？
这时就可以利用适配器模式，将上面各中方式都适配成一个接口。
```java

/**
 * @see AbstractBeanFactory
 */
protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
    AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
    if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
        if (mbd.isSingleton()) {
            // Register a DisposableBean implementation that performs all destruction
            // work for the given bean: DestructionAwareBeanPostProcessors,
            // DisposableBean interface, custom destroy method.
            registerDisposableBean(beanName,
                    new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
        else {
            // A bean with a custom scope...
            Scope scope = this.scopes.get(mbd.getScope());
            if (scope == null) {
                throw new IllegalStateException("No Scope registered for scope name '" + mbd.getScope() + "'");
            }
            scope.registerDestructionCallback(beanName,
                    new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
    }
}

class DisposableBeanAdapter implements DisposableBean, Runnable, Serializable {
    ....
    public DisposableBeanAdapter(Object bean, String beanName, RootBeanDefinition beanDefinition,
            List<BeanPostProcessor> postProcessors, @Nullable AccessControlContext acc) {

        Assert.notNull(bean, "Disposable bean must not be null");
        this.bean = bean;
        this.beanName = beanName;
        this.invokeDisposableBean =
                (this.bean instanceof DisposableBean && !beanDefinition.isExternallyManagedDestroyMethod("destroy"));
        this.nonPublicAccessAllowed = beanDefinition.isNonPublicAccessAllowed();
        this.acc = acc;
        String destroyMethodName = inferDestroyMethodIfNecessary(bean, beanDefinition);
        if (destroyMethodName != null && !(this.invokeDisposableBean && "destroy".equals(destroyMethodName)) &&
                !beanDefinition.isExternallyManagedDestroyMethod(destroyMethodName)) {
            this.destroyMethodName = destroyMethodName;
            Method destroyMethod = determineDestroyMethod(destroyMethodName);
            if (destroyMethod == null) {
                if (beanDefinition.isEnforceDestroyMethod()) {
                    throw new BeanDefinitionValidationException("Could not find a destroy method named '" +
                            destroyMethodName + "' on bean with name '" + beanName + "'");
                }
            }
            else {
                Class<?>[] paramTypes = destroyMethod.getParameterTypes();
                if (paramTypes.length > 1) {
                    throw new BeanDefinitionValidationException("Method '" + destroyMethodName + "' of bean '" +
                            beanName + "' has more than one parameter - not supported as destroy method");
                }
                else if (paramTypes.length == 1 && boolean.class != paramTypes[0]) {
                    throw new BeanDefinitionValidationException("Method '" + destroyMethodName + "' of bean '" +
                            beanName + "' has a non-boolean parameter - not supported as destroy method");
                }
                destroyMethod = ClassUtils.getInterfaceMethodIfPossible(destroyMethod);
            }
            this.destroyMethod = destroyMethod;
        }
        this.beanPostProcessors = filterPostProcessors(postProcessors, bean);
    }

    ...
}
```