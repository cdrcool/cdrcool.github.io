---
title: Kafka精确一次语义
date: 2020-01-21 16:06:00
categories: Kafka
---
## 消息交付可靠性保障
在介绍精确一次语义之前，我们先了解下什么是消息交付可靠性保障。
所谓消息交付可靠性保障，是消息引擎对 Producer 和 Consumer 要处理的消息提供什么样的承诺。常见的承诺有以下三种：
* 最多一次（at most once）：消息可能会丢失，但绝不会重复消费。
* 至少一次（at lease once）：消息不会丢失，但有可能被重复发送。
* 精确一次（exactly once）：消息不会丢失，也不会被重复发送。

目前，Kafka 默认提供的交付可靠性保障是第二种，即至少一次。
在 Kafka 中，只有 Broker 成功“提交”消息且 Producer 接到 Broker 的应答才会认为该消息成功发送。不过倘若消息成功“提交”，但 Broker 的应答没有成功发送回 Producer 端（比如网络出现瞬时抖动），那么 Producer 就无法确定消息是否真的提交成功了。因此，它只能选择重试，也就是再次发送相同的消息。这就是 Kafka 默认提供至少一次可靠性保障的原因，不过这会导致消息重复发送。

Kafka 也能提供对最多一次交付保障，只需要让 Producer 禁止重试即可。这样一来，消息要么写入成功，要么写入失败，但绝不会重新发送。我们通常不会希望出现消息丢失的情况，但在一些场景里偶发的消息丢失其实是被允许的，相反，消息重复消费是绝对要避免的。此时，使用最多一次交付保障就是最恰当的。

无论至少一次还是最多一次，都不如精确一次来得有吸引力。大部分用户还是希望消息只被交付一次，这样，消息不会丢失，也不会被重复处理。或者说，即使 Producer 端重复发送了相同的消息，Broker 端也能做到自动去重。在下游 Consumer 看来，消息依然只有一条。

那么问题来了，Kafka 是怎么做到精确一次的呢？简单来说，这是通过两种机制：幂等性（Idempotence）和事务（Transaction）。

## 幂等性 Producer
在 Kafka 中，Producer 默认不是幂等性的，但我们可以创建幂等性 Producer，只需要设置属性 enable.idempotence 为 true 即可。

不过，幂等性 Producer是有多用范围的。
首先，它只能保证单分区上的幂等性，即一个幂等性 Producer 能够保证某个主题的一个分区不出现重复消息，它无法实现多个分区的幂等性。
其次，它只能实现单会话上的幂等性，不能实现跨会话的幂等性。这里的会话，我们可以理解为 Producer 进程的一次运行。当我们重启了 Producer 进程之后，这种幂等性保证就丧失了。

如果我们想实现对分区以及多会话上的消息无重复，则需要使用事务型 Producer。

## 事务型 Producer
事务型 Producer 能够保证将消息原子性地写入到多个分区中。这批消息要么全部写入成功，要么全部失败。另外，事务型 Producer 也不惧进程的重启。Producer 重启回来后，Kafka 依然保证它们发送消息的精确一次处理。

设置事务型 Producer 的方法也很简单，只需配置以下两个属性：
* 和幂等性 Producer 一样，开启 enable.idempotence = true。
* 设置 Producer 端参数 transactional.id。最好为其设置一个有意义的名字。

实际上即使消息写入失败，Kafka 也会把它们写入到底层的日志中，也就是说 Consumer 还是会看到这些消息。因此在 Consumer 端，读取事务型 Producer 发送的消息也需要做一些变更：设置 isolation.level 参数的值。目前该参数有两个取值：
* read_uncommitted
这是默认值，表明 Consumer 能够读取到 Kafka 写入的任何消息，不论事务型 Producer 提交事务还是终止事务，其写入的消息都可以读取。很显然，如果我们用了事务型 Producer，那么对应的 Consumer 就不要使用这个值。
* read_committed
表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消息。当然，它也能看到非事务型 Producer 写入的所有消息。

尽管从交付语义上来看，事务型 Producer 能做的更多。但是事务型 Producer 的性能要更差，在实际使用过程中，我们需要仔细评估引入事务的开销，切不可无脑地启用事务。

## 事务应用示例
我们以订单和购物车这个例子来介绍 Kafka 是如何实现分布式事务的。

![Kafka事务应用示例](/images/kafka/Kafka事务应用示例.png)

如上图所示：
首先，订单系统在消息队列上开启一个事务。
然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。
半消息发送成功之后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。
如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息，这样就基本实现了“要么都成功，要么都失败”的一致性要求。

在上面的实现过程中，有一个问题其实是没有解决的：如果在第四步提交事务消息时失败了怎么办？Kafka 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，知道提交成功，或者删除之前创建的订单进行补偿。