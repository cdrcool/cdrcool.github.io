---
title: 设计模式--中介者模式
date: 2019-09-02 14:40:21
categories: 设计模式
tags:
	- 中介者模式
---
## 定义
**中介者模式**定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。

## 角色
* 抽象中介者（Mediator）：定义同事对象到中介者对象之间的接口。
* 具体中介者（ConcreteMediator）：实现抽象中介者的方法，它需要知道所有的具体同事类，同时要从具体的同时类那里接收消息，并且向具体的同事类发送消息。
* 抽象同事类（Colleague）：定义中介者对象的接口，它只知道中介者而不知道其它的同事对象。
* 具体同事类（ConcreteColleague）：每个具体同事类都只需要知道自己的行为即可，但是它们都需要认识中介者。

## 类图
![Mediator UML](/images/design-patterns/Mediator%20UML.png)

## 实现
```java
/**
 * 同事类接口
 */
public interface Colleague {

    /**
     * 操作
     */
    void operation();
}

/**
 * 具体同事类A
 */
public class ConcreteColleagueA implements Colleague {

    @Override
    public void operation() {
        System.out.println("A operation");
    }
}

/**
 * 具体同事类B
 */
public class ConcreteColleagueB implements Colleague {

    @Override
    public void operation() {
        System.out.println("B operation");
    }
}

/**
 * 抽象中介者
 */
public abstract class Mediator {
    protected ConcreteColleagueA colleagueA;
    protected ConcreteColleagueB colleagueB;

    public Mediator() {
        colleagueA = new ConcreteColleagueA();
        colleagueB = new ConcreteColleagueB();
    }

    /**
     * 操作
     *
     * @param message 消息
     */
    abstract void operation(String message);
}

/**
 * 具体中介者
 */
public class ConcreteMediator extends Mediator {

    @Override
    public void operation(String message) {
        if ("A".equals(message)) {
            colleagueA.operation();
            colleagueB.operation();
        } else if ("B".equals(message)) {
            colleagueB.operation();
            colleagueA.operation();
        }
    }
}
```

## 优缺点
### 优点
* 简化了对象之间的关系，将系统各个对象之间的关系进行封装，将各个同事类进行解耦，使得系统变为松耦合
* 提供系统的灵活性，使得各个同事对象独立而易于复用

### 缺点
* 中介者角色承担了较多的责任，所以一旦这个中介者对象出了问题，整个系统将会受到重大的影响
* 新增加一个同事类时，不得不去修改抽象终结者类和具体中介者类（可以使用观察者模式和状态模式来解决这个问题）

## 适用场景
* 一组定义良好的对象，现在要进行复杂的通信
* 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类

## 模式应用