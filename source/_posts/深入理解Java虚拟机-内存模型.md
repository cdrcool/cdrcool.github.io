---
title: 深入理解Java虚拟机-内存模型
date: 2020-04-11 12:32:00
categories: Java虚拟机
---
Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。

Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需通过主内存来完成，线程、主内存、工作内存三者交互关系如下图所示：

![内存模型](/images/java/内存模型.webp)

这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。如果一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储与寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。

## 内存间交互操作
Java 内存模型中定义了以下 8 种操作，Java 虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外）。
* lock（锁定）
* unlock（解锁）
* read（读取）
* load（载入）
* use（使用）
* assign（赋值）
* store（存储）
* write（写入）

如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要按顺序执行 store 和 write 操作。注意，Java 内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。

## volatile 型变量的特殊规则
当一个变量被定义成 volatile 之后，它将具备两项特性：第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

需要说明的是，基于 volatile 变量的运算并不能保证在并发下一定是线程安全的，在不符合以下两条规则的运算场景中，仍然要通过加锁来保证原子性：
* 运算结果并不依赖变量的当前值，或者能确保只有单一的线程修改变量的值。
* 变量不需要与其他的胡藏太变量共同参与不变约束。

使用 volatile 变量的第二个语义是禁止指令重排序优化。

## 原子性、可见性与有序性
* 原子性
* 可见性
* 有序性

## 先行发生原则
先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，比如说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括了修改了内存中共享变量的值、发送了消息、调用了方法等。

下面是 Java 内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。

* 程序次序原则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

* 管程锁定原则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

* volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

* 线程启动规则（Thread Start Rule）：Thread 对象的 start 方法先行发生于此线程的每一个动作。

* 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测。

* 线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。

* 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

* 传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于 操作 C 的结论。