<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="OnePiece">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="OnePiece">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="晴天">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>OnePiece</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">OnePiece</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">人的知识就好比一个圆圈，圆圈里面是已知的，圆圈外面是未知的。你知道得越多，圆圈也就越大，你不知道的也就越多。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/Spring%20Cloud%20Gateway%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97(%E4%B8%80)%20Route%20Predicate%20Factories/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/Spring%20Cloud%20Gateway%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97(%E4%B8%80)%20Route%20Predicate%20Factories/" class="post-title-link" itemprop="url">Spring Cloud Gateway 开发指南（一） Route Predicate Factories</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-27 11:22:00" itemprop="dateCreated datePublished" datetime="2020-02-27T11:22:00+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Spring Cloud Gateway 包含许多内置的路由 predicate factories。所有这些 predicates 都匹配 HTTP 请求的不同属性。我们可以将多个路由 predicate factories 与逻辑和语句组合在一起。</p>
<h2 id="After"><a href="#After" class="headerlink" title="After"></a>After</h2><p>接受一个日期类型参数。此 Predicate 匹配在指定日期时间之后发生的请求。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<p>该路由与丹佛时间 2017年1月20日17点42分 之后的任何请求相匹配。</p>
<h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><p>接受一个日期类型参数。此 Predicate 匹配在指定日期时间之前发生的请求。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<p>该路由与丹佛时间 2017年1月20日17点42分 之前的任何请求相匹配。</p>
<h2 id="Between"><a href="#Between" class="headerlink" title="Between"></a>Between</h2><p>接受两个个日期类型参数：datetime1 和 datetime2。此 Predicate 匹配在 datetime1 之后和 datetime2 之前发生的请求。datetime2 参数必须位于 datetime1 之后。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">between_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver]，2017-01-21T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure>

<p>该路由与丹佛时间 2017年1月20日17点42分 之后和丹佛时间 2017年1月21日17:42 之前的任何请求匹配。这对于维护窗口可能很有用。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>接受两个参数：cookie 名称和一个正则表达式。此 Predicate 匹配具有给定名称且其值与正则表达式匹配的 cookie。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cookie_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=chocolate，ch.p</span></span><br></pre></td></tr></table></figure>

<p>该路由匹配具有一个名为 chocolate 的 cookie 的请求，该 cookie 的值与 ch.p 正则表达式匹配。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>接受两个参数：header 名称和一个正则表达式。此 Predicate 与具有给定名称(其值与正则表达式匹配)的 header 匹配。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Header=X-Request-Id，\d+</span></span><br></pre></td></tr></table></figure>

<p>如果请求的 header 名为 X-Request-Id，其值与 \d+ 正则表达式匹配(即，它的值为一个或多个数字)，则该路由将进行匹配。</p>
<h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><p>接受一个参数：host name patterns 列表。此 Predicate 与与模式匹配的 Host header 匹配。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br></pre></td></tr></table></figure>

<p>还支持 URI 模板变量(例如 {sub}.myhost.org)。</p>
<p>如果请求的 Host header 的值为 www .somehost.org 或 beta.somehost.org 或 www .anotherhost.org，则该路由将进行匹配。</p>
<p>此 Predicate 将 URI 模板变量(如前面示例中定义的 sub)提取为名称和值的映射，并将其放在 ServerWebExchange.getAttributes() 中，并在 ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE 中定义一个键。然后这些值可供 GatewayFilter 工厂使用。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>接受一个或多个参数：要匹配的 HTTP 方法。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>

<p>如果请求方法是 GET 或 POST，则该路由匹配。</p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>接受两个参数:一个 Spring PathMatcher 模式列表和一个名为 matchOptionalTrailingSeparator 的可选标志。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果请求路径为，例如: /red/1 或 /red/blue 或 /blue/green，则该路由匹配。</p>
<p>此 Predicate 将 URI 模板变量(如前面示例中定义的片段)提取为名称和值的映射，并将其放入 ServerWebExchange.getAttributes() 中，并在 ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE 中定义了一个键。然后这些值可供 GatewayFilter 工厂使用。</p>
<p>可以使用实用程序方法(称为 get)来简化对这些变量的访问。下面的例子展示了如何使用 get 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String，String&gt; uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);</span><br><span class="line"></span><br><span class="line">String segment = uriVariables.get(<span class="string">"segment"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><p>接受两个参数：一个必需的参数和一个可选的 regexp。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=green</span></span><br></pre></td></tr></table></figure>

<p>如果请求包含 green 查询参数，则前面的路由匹配。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=red，gree.</span></span><br></pre></td></tr></table></figure>

<p>如果请求包含一个 red 查询参数，其值与 gree. 正则表达式 匹配，则前面的路由匹配。</p>
<h2 id="RemoteAddr"><a href="#RemoteAddr" class="headerlink" title="RemoteAddr"></a>RemoteAddr</h2><p>接受 CIDR-notation(IPv4 或 IPv6) 字符串列表(最小大小为 1)，比如 192.168.0.1/16 (其中 192.168.0.1 是一个 IP 地址，16 是子网掩码)。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure>

<p>如果请求的远程地址是 192.168.1.10，则该路由匹配。</p>
<h2 id="Weight"><a href="#Weight" class="headerlink" title="Weight"></a>Weight</h2><p>有两个参数：组和权值。每组计算权重。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_high</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weighthigh.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1，8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_low</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weightlow.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1，2</span></span><br></pre></td></tr></table></figure>

<p>该路由将 80% 的流量转发到 weighthigh.org，20%  的流量转发到 weightlow.org。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/" target="_blank" rel="noopener">Spring Cloud Gateway</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/Spring%20Cloud%20Consul%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/Spring%20Cloud%20Consul%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Spring Cloud Consul 开发指南</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 15:21:00" itemprop="dateCreated datePublished" datetime="2020-02-26T15:21:00+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装-Consul"><a href="#安装-Consul" class="headerlink" title="安装 Consul"></a>安装 Consul</h2><p>有关如何安装 Consul 的说明，参阅安装文档 <a href="https://www.consul.io/intro/getting-started/install.html" target="_blank" rel="noopener"> installation documentation</a>。</p>
<h2 id="Consul-Agent"><a href="#Consul-Agent" class="headerlink" title="Consul Agent"></a>Consul Agent</h2><p>所有 Spring Cloud Consul 应用程序都必须有 Consul Agent。默认情况下，代理客户端位于 localhost:8500。有关如何启动代理客户端以及如何连接到 Consul 代理服务器群集的详细信息，参阅 <a href="https://consul.io/docs/agent/basics.html" target="_blank" rel="noopener">Agent documentation</a>。为了进行开发，安装 Consul 后，可以使用以下命令启动 Consul 代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./src/main/bash/local_run_consul.sh</span><br></pre></td></tr></table></figure>

<p>这将在端口 8500上以服务器模式启动代理，并在 <a href="http://localhost:8500/" target="_blank" rel="noopener">http://localhost:8500/</a> 上提供用户界面。</p>
<h2 id="服务发现与-Consul"><a href="#服务发现与-Consul" class="headerlink" title="服务发现与 Consul"></a>服务发现与 Consul</h2><p>服务发现是基于微服务架构的关键原则之一。尝试手动配置每个客户端或某种形式的约定可能非常困难，也可能非常脆弱。Consul 通过 HTTP API 和 DNS 提供服务发现服务。Spring Cloud Consul 利用 HTTP API 进行服务注册和发现。这并不妨碍非 Spring Cloud 应用程序利用 DNS 接口。Consul Agents 服务器在集群中运行，集群通过 gossip 协议进行通信，并使用 Raft 共识协议。</p>
<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>要激活 Consul 服务发现，，需引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注册-与-Consul"><a href="#注册-与-Consul" class="headerlink" title="注册 与 Consul"></a>注册 与 Consul</h3><p>当客户端向 Consul 注册时，它会提供有关自身的元数据，如主机和端口、id、名称和标签。默认情况下，会创建一个 HTTP 检查，Consul 每 10 秒访问一次 /health 端点。如果运行状况检查失败，则将服务实例标记为严重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application<span class="class">.<span class="keyword">class</span>).<span class="title">web</span>(<span class="title">true</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（即完全正常的 Spring Boot 应用程序）。如果 Consul 客户端位于 localhost:8500 以外的其它位置，则需要配置来定位客户端。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果使用 Spring Cloud Consul Config，则需要将上述值放在 bootstrap.yml 而不是 application.yml 中。</p>
<p>从环境中获取的默认服务名、实例 id 和端口分别是 ${spring.application.name}、Spring Context ID 和 ${server.port}。</p>
<p>要禁用 Consul Discovery客户端，可以将 spring.cloud.consul.discovery.enabled 设置为 false。当 spring.cloud.discovery.enabled 设置为 false 时，Consul Discovery Client 也将被禁用。</p>
<p>要禁用服务注册，可以将 spring.cloud.consul.discovery.register 设置为 false。</p>
<h3 id="HTTP-健康检查"><a href="#HTTP-健康检查" class="headerlink" title="HTTP 健康检查"></a>HTTP 健康检查</h3><p>Consul 实例的健康检查默认为 “/health”，这是 Spring Boot Actuator 应用程序中一个有用的端点的默认位置。如果使用非默认的上下文路径或 servlet 路径（例如 server.servletPath=/foo）或 management 端点路径（例如 management.server.servlet.context-path=/admin），则即使是 Actuator 应用程序，也需要更改这些内容。Consul 用来检查健康端点的时间间隔也可以配置。“10s” 和 “1min” 分别代表 10 秒和 1 分钟。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">healthCheckPath:</span> <span class="string">$&#123;management.server.servlet.context-path&#125;/health</span></span><br><span class="line">        <span class="attr">healthCheckInterval:</span> <span class="string">15s</span></span><br></pre></td></tr></table></figure>

<p>可以通过设置 management.health.consul.enabled=false 来禁用运行状况检查。</p>
<h4 id="元数据和-Consul-标签"><a href="#元数据和-Consul-标签" class="headerlink" title="元数据和 Consul 标签"></a>元数据和 Consul 标签</h4><p>Consul 还不支持服务的元数据。Spring Cloud 的 ServiceInstance 有一个 Map&lt;String，String&gt; 元数据字段。在 Consul 正式支持元数据之前，Spring Cloud Consul 使用 Consul 标记来近似元数据。格式为 key=value 的标签将被拆分，并分别用作映射键和值。不带等号的标记将同时用作键和值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">tags:</span> <span class="string">foo=bar,</span> <span class="string">baz</span></span><br></pre></td></tr></table></figure>

<p>上面的配置将得到一个 foo→bar 和 baz→baz 的映射。</p>
<h4 id="使-Consul-实例-ID-唯一"><a href="#使-Consul-实例-ID-唯一" class="headerlink" title="使 Consul 实例 ID 唯一"></a>使 Consul 实例 ID 唯一</h4><p>默认情况下，Consul 实例注册的 ID 等于它的 Spring 应用程序上下文 ID。默认情况下，Spring 应用程序上下文 ID 是  ${spring.application.name}:comma,separated,profiles:${server.port}。对于大多数情况，这将允许一台机器上运行一个服务的多个实例。如果需要进一步的唯一性，通过使用 Spring Cloud，可以通过在 spring.cloud.consul.discovery.instanceId 中提供唯一的标识符来覆盖它。例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">instanceId:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>有了这个元数据和部署在 localhost 上的多个服务实例，随机值将进入其中，使实例唯一。在 Cloudfoundry 中，vcap.application.instance_id 将在 Spring 引导应用程序中自动填充，因此不需要随机值。</p>
<h4 id="在运行状况检查请求中应用-Headers"><a href="#在运行状况检查请求中应用-Headers" class="headerlink" title="在运行状况检查请求中应用 Headers"></a>在运行状况检查请求中应用 Headers</h4><p>Headers 可以应用于健康检查请求。例如，如果要注册使用了 Vault Backend 的 Spring Cloud Config 服务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">health-check-headers:</span></span><br><span class="line">          <span class="attr">X-Config-Token:</span> <span class="string">6442e58b-d1ea-182e-cfa5-cf9cddef0722</span></span><br></pre></td></tr></table></figure>

<p>根据 HTTP 标准，每个 header 可以有多个值，在这种情况下，可以提供一个数组：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">health-check-headers:</span></span><br><span class="line">          <span class="attr">X-Config-Token:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"6442e58b-d1ea-182e-cfa5-cf9cddef0722"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"Some other value"</span></span><br></pre></td></tr></table></figure>

<h3 id="查找服务"><a href="#查找服务" class="headerlink" title="查找服务"></a>查找服务</h3><h4 id="使用-Load-balancer"><a href="#使用-Load-balancer" class="headerlink" title="使用 Load-balancer"></a>使用 Load-balancer</h4><p>Spring Cloud 支持 Feign 和 Spring RestTemplate，用于使用逻辑服务 names/id 而不是物理 URLs 查找服务。Feign 和 discovery-aware RestTemplate 都利用 Ribbon 来实现客户端负载平衡。</p>
<p>如果我们想使用 RestTemplate 访问服务 STORES，只需声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">loadbalancedRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并像这样使用（注意我们如何使用 Consul 中的 STORES 服务 name/id 而不是完全限定的域名）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFirstProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"https://STORES/products/1"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在多个数据中心中有 Consul 集群，并且希望访问另一个数据中心中的服务，仅使用服务 name/id 是不够的。在这种情况下，使用属性 spring.cloud.consul.discovery.datacenters.STORES=dc-west，其中 STORES 是服务 name/id，dc-west 是 STORES 服务所在的数据中心。</p>
<p>Spring Cloud 现在还支持Spring Cloud LoadBalancer。</p>
<p><strong>注意：</strong> 由于 Spring Cloud Ribbon 目前处于维护中，建议大家将 Spring.Cloud.loadbalancer.Ribbon.enabled 设置为 false，以便使用 BlockingLoadBalancerClient 而不是 RibbonLoadBalancerClient。</p>
<h4 id="使用-DiscoveryClient"><a href="#使用-DiscoveryClient" class="headerlink" title="使用 DiscoveryClient"></a>使用 DiscoveryClient</h4><p>我们还可以使用 org.springframework.cloud.client.discovery.DiscoveryClient，它为非特定于 Netflix 的发现客户端提供了一个简单的 API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serviceUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"STORES"</span>);</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        URI uri = list.get(<span class="number">0</span>).getUri();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consul-Catalog-Watch"><a href="#Consul-Catalog-Watch" class="headerlink" title="Consul Catalog Watch"></a>Consul Catalog Watch</h3><p>Consul Catalog Watch 利用 Consul 的能力来 <a href="https://www.consul.io/docs/agent/watches.html#services" target="_blank" rel="noopener">watch services</a>。Catalog Watch 执行一个阻塞的 Consul HTTP API 调用，以确定是否有任何服务发生了变化。如果有新的服务数据，就会发布 Heartbeat Event。</p>
<p>可以通过调整 spring.cloud.consul.config.discovery.catalog-services-watch-delay 的值，来改变 Config Watch 调用的频率。默认值是 1000，以毫秒为单位。延迟是上一次调用结束和下一次调用开始后的时间量。</p>
<p>要禁用 Catalog Watch，设置 spring.cloud.consul.discovery.catalogServicesWatch.enabled=false。</p>
<p>该 watch 使用一个 Spring TaskScheduler 来调度与 Consul 的通话。默认情况下，它是一个 poolSize 为 1 的 ThreadPoolTaskScheduler。若要更改 TaskScheduler，需要创建一个类型为 TaskScheduler 的 bean，该 bean 的名称为 ConsulDiscoveryClientConfiguration.CATALOG_WATCH_TASK_SCHEDULER_NAME 常数。</p>
<h2 id="Consul-分布式配置"><a href="#Consul-分布式配置" class="headerlink" title="Consul 分布式配置"></a>Consul 分布式配置</h2><p>Consul 提供用于存储配置和其它元数据的 <a href="https://consul.io/docs/agent/http/kv.html" target="_blank" rel="noopener">Key/Value Store</a>。Spring Cloud Consul Config 是 <a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">Config Server and Client</a> 的替代品。Configuration 是在特殊的“bootstrap”阶段被加载到Spring Environment 中。Configuration 默认存储在 /config 文件夹中。根据应用程序的名称和激活的 profiles 创建多个 PropertySource 实例，这些激活的 profiles 模仿 Spring Cloud Config 中解析属性的顺序。例如，一个名为“testApp”并带有“dev” profile 的应用程序将创建以下属性源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config&#x2F;testApp,dev&#x2F;</span><br><span class="line">config&#x2F;testApp&#x2F;</span><br><span class="line">config&#x2F;application,dev&#x2F;</span><br><span class="line">config&#x2F;application&#x2F;</span><br></pre></td></tr></table></figure>

<p>最具体的属性源位于顶部，最不具体的位于底部。config/application 文件夹中的属性适用于使用 Consul 进行配置的所有应用程序。config/testApp 文件夹中的属性仅对名为“testApp”的服务实例可用。</p>
<p>当前 Configuration 是在应用程序启动时读取。向 /refresh 发送 HTTP POST 将导致重新加载配置。Config Watch 还将自动检测变化并重新加载应用程序上下文。</p>
<h3 id="激活-1"><a href="#激活-1" class="headerlink" title="激活"></a>激活</h3><p>要开始使用 Consul Configuration，需引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这将启用 Spring Cloud Consul Config 的自动装配。</p>
<h3 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h3><p>Consul Config 可以使用以下属性自定义：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">configuration</span></span><br><span class="line">        <span class="attr">defaultContext:</span> <span class="string">apps</span></span><br><span class="line">        <span class="attr">profileSeparator:</span> <span class="string">'::'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>enabled 将此值设置为 false 将禁用 Consul Config。</li>
<li>prefix 设置配置值的基本文件夹。</li>
<li>defaultContext 设置所有应用程序使用的文件夹名。</li>
<li>profileSeparator 设置用于用 profiles 文件分隔属性源中的概要文件名称的分隔符的值</li>
</ul>
<h3 id="Config-Watch"><a href="#Config-Watch" class="headerlink" title="Config Watch"></a>Config Watch</h3><p>Consul Config Watch 利用 Consul 的能力来 <a href="https://www.consul.io/docs/agent/watches.html#keyprefix" target="_blank" rel="noopener">watch a key prefix</a>。Config Watch 执行阻塞的 Consul HTTP API 调用，以确定当前应用程序的任何相关配置数据是否已更改。如果有新的配置数据，则会发布刷新事件。这相当于调用了 /refresh actuator 端点。</p>
<p>可以通过调整 spring.cloud.consul.config.watch.delay 的值，来改变 Config Watch 调用的频率。默认值是 1000，以毫秒为单位。延迟是上一次调用结束和下一次调用开始后的时间量。</p>
<p>要禁用 Config Watch，设置 spring.cloud.consul.config.watch.enabled=false。</p>
<p>该 watch 使用一个 Spring TaskScheduler 来调度与 Consul 的通话。默认情况下，它是一个 poolSize 为 1 的 ThreadPoolTaskScheduler。若要更改 TaskScheduler，需要创建一个类型为 TaskScheduler 的 bean，该 bean 的名称为 ConsulConfigAutoConfiguration.CONFIG_WATCH_TASK_SCHEDULER_NAME 常数。</p>
<h3 id="YAML-或-Properties-与配置"><a href="#YAML-或-Properties-与配置" class="headerlink" title="YAML 或 Properties 与配置"></a>YAML 或 Properties 与配置</h3><p>与单独的 key/value 对相比，以 YAML 或 Properties 格式存储配置属性可能更方便。设置 spring.cloud.consul.config.format 属性为 YAML 或 PROPERTIES。例如使用 YAML：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">YAML</span></span><br></pre></td></tr></table></figure>

<p>YAML 必须在 Consul 的适当 data key 中设置。使用上面的默认 keys 看起来像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config&#x2F;testApp,dev&#x2F;data</span><br><span class="line">config&#x2F;testApp&#x2F;data</span><br><span class="line">config&#x2F;application,dev&#x2F;data</span><br><span class="line">config&#x2F;application&#x2F;data</span><br></pre></td></tr></table></figure>

<p>我们可以在上面列出的任意 keys 中存储 YAML 文档。</p>
<p>我们可以使用 spring.cloud.consul.config.data-key 来更改 data key。</p>
<h3 id="git2consul-与配置"><a href="#git2consul-与配置" class="headerlink" title="git2consul 与配置"></a>git2consul 与配置</h3><p>git2consul 是一个 Consul 社区项目，它将文件从 git 存储库加载到 Consul 中的各个 key 中。默认情况下，key 的名称是文件的名称。YAML 和 Properties 文件分别支持 .yml 和 .properties 文件扩展名。设置 spring.cloud.consul.config.format=FILES。例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">FILES</span></span><br></pre></td></tr></table></figure>

<p>在 /config 中给定以下 keys，development profile 和 foo 的 application name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br><span class="line">application.yml</span><br><span class="line">bar.properties</span><br><span class="line">foo-development.properties</span><br><span class="line">foo-production.yml</span><br><span class="line">foo.properties</span><br><span class="line">master.ref</span><br></pre></td></tr></table></figure>

<p>将创建以下属性源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config&#x2F;foo-development.properties</span><br><span class="line">config&#x2F;foo.properties</span><br><span class="line">config&#x2F;application.yml</span><br></pre></td></tr></table></figure>

<p>每个 key 的值必须是格式正确的 YAML 或 Properties 文件。</p>
<h3 id="快速失败（Fail-Fast）"><a href="#快速失败（Fail-Fast）" class="headerlink" title="快速失败（Fail Fast）"></a>快速失败（Fail Fast）</h3><p>在某些情况下（如本地开发或某些测试场景），如果 Consul 无法进行配置，则不失败可能很方便。在 bootstrap.yml 中设置 spring.cloud.consul.config.failFast=false 可以让配置模块记录一个警告，而不是抛出一个异常。这将允许应用程序继续正常启动。</p>
<h2 id="Consul-重试"><a href="#Consul-重试" class="headerlink" title="Consul 重试"></a>Consul 重试</h2><p>如果我们预计在应用程序启动时 Consul Agent 偶尔不可用，可以要求它在失败后继续尝试。我们需要将 spring-retry 和 spring-boot-starter-aop 添加到类路径中。默认行为是重试 6 次，初始回退间隔为 1000ms，后续回退的指数乘数为 1.1。我们可以使用 spring.cloud.consul.retry.* 配置属性来配置这些属性(以及其它属性)。这可以在 Spring Cloud Consul Config 和 Discovery registration 中使用。</p>
<p>要完全控制重试，可以添加一个类型为 RetryOperationsInterceptor、id 为 consulRetryInterceptor 的 @Bean。Spring Retry 提供了一个 RetryInterceptorBuilder，可以很容易地创建一个。</p>
<h2 id="Spring-Cloud-Bus-与-Consul"><a href="#Spring-Cloud-Bus-与-Consul" class="headerlink" title="Spring Cloud Bus 与 Consul"></a>Spring Cloud Bus 与 Consul</h2><h3 id="激活-2"><a href="#激活-2" class="headerlink" title="激活"></a>激活</h3><p>要开始使用 Consul Bus，需引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-bus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有关可用的 actuator 端点和如何发送自定义消息，参阅 <a href="https://cloud.spring.io/spring-cloud-bus/" target="_blank" rel="noopener">Spring Cloud Bus</a> 文档。</p>
<h2 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h2><p>要查看所有 Consul 相关配置属性的列表，请查看<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-consul/2.2.1.RELEASE/reference/html/appendix.html" target="_blank" rel="noopener">附录页面</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-consul/2.2.1.RELEASE/reference/html/" target="_blank" rel="noopener">Spring Cloud Consul</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/Spring%20Cloud%20Gateway%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/Spring%20Cloud%20Gateway%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Spring Cloud Gateway 开发实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 14:32:00" itemprop="dateCreated datePublished" datetime="2020-02-26T14:32:00+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网关 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment"># 秒杀服务</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">seckill</span></span><br><span class="line"><span class="comment">#          uri: lb://seckill</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8081</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api-seckill/**</span></span><br><span class="line">        <span class="comment"># 账号服务</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">account</span></span><br><span class="line"><span class="comment">#          uri: lb://account</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8082</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api-account/**</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br></pre></td></tr></table></figure>

<p>如上，我们访问网关地址 localhost:8080/api-account/ 时，经网关路由转发之后，地址就是 localhost:8082/。</p>
<ul>
<li>如果我们要使用负载均衡，uri 需配置为 lb://account，account 为属性 spring.application.name 指定的名称。</li>
<li>示例中 StripPrefix=1 是必须的，表示 StripPrefix 过滤器将去掉 URL 路径中的第一个前缀，这里是 api-account。</li>
</ul>
<h2 id="熔断与降级"><a href="#熔断与降级" class="headerlink" title="熔断与降级"></a>熔断与降级</h2><h3 id="Maven-依赖-1"><a href="#Maven-依赖-1" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 断路器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-circuitbreaker-reactor-resilience4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>可以通过设置 spring.cloud.circuitbreaker.resilience4j.enabled=false 来禁用 Resilience4J 自动装配。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="comment"># 断路器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CircuitBreaker</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">circuitBreaker</span></span><br><span class="line">            <span class="comment"># 降级 URI</span></span><br><span class="line">            <span class="attr">fallback-uri:</span> <span class="string">forward:/fallback</span></span><br></pre></td></tr></table></figure>

<p>如上，我们访问网关地址 localhost:8080/api-seckill/ 时，如果此时 seckill 服务还未启动，那么网关会触发熔断，并将请求转发到 mapping 为 fallback 的 Controller，以实现服务降级。</p>
<p>在上面的示例中，我们是将请求转发到网关内部的 Controller，我们也可以将请求重新路由到外部应用程序中的 Controller，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://ingredients</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=//ingredients/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CircuitBreaker</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">fetchIngredients</span></span><br><span class="line">            <span class="attr">fallbackUri:</span> <span class="string">forward:/fallback</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ingredients-fallback</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:9994</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/fallback</span></span><br></pre></td></tr></table></figure>

<p>在新的示例中，当我们访问 ingredients 服务并出现熔断后，请求首先会被转发到 fallback，然后再被重新路由到 localhost:9994。</p>
<p>在前面的示例中，我们只是简单配置了 fallback，如果要对断路器做一些高级的配置，如熔断策略、异常处理等，参考 <a href="https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html" target="_blank" rel="noopener">Resilience4J 文档</a></p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h3 id="Maven-依赖-2"><a href="#Maven-依赖-2" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 限流（基于redis） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="comment"># 限流</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="comment"># 限流匹配策略</span></span><br><span class="line">            <span class="attr">key-resolver:</span> <span class="string">'#&#123;@ipKeyResolver&#125;'</span></span><br><span class="line">            <span class="comment"># 令牌桶的填充速率：用户每秒执行多少请求</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">10</span></span><br><span class="line">            <span class="comment"># 令牌桶的容量：用户在一秒钟内执行的最大请求数</span></span><br><span class="line">            <span class="comment"># 将此值设置为零将阻塞所有请求；将此值设置为高于 replenishRate，以允许临时突发</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>如上：</p>
<ul>
<li>限制了用户每秒最多执行 10 次请求；</li>
<li>限制了用户在一秒钟内最多执行 20 次请求；</li>
<li>限流匹配策略使用 ipKeyResolver(ip 限流)，ipKeyResolver 为 Spring Bean 的名称。</li>
</ul>
<p>我们可以自定义各种 KeyResolver，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrottlingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_ID_NAME = <span class="string">"userId"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">apiKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getPath().value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ip 限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">ipKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">principalNameKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrincipalNameKeyResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户限流（要求请求路径中必须携带 userId 参数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">userKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getQueryParams().getFirst(USER_ID_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="断路器配置"><a href="#断路器配置" class="headerlink" title="断路器配置"></a>断路器配置</h3><p>使用断路器，我们也能实现限流，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customizer&lt;ReactiveResilience4JCircuitBreakerFactory&gt; <span class="title">defaultCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; <span class="keyword">new</span> Resilience4JConfigBuilder(id)</span><br><span class="line">                .circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())</span><br><span class="line">                <span class="comment">// 限制远程调用所花费的时间</span></span><br><span class="line">                .timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(<span class="number">5</span>)).build()).build());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求耗时统计"><a href="#请求耗时统计" class="headerlink" title="请求耗时统计"></a>请求耗时统计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElapsedGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 请求执行之前的时间</span></span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then().then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 请求执行之后的时间</span></span><br><span class="line">            Long endTime = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">"请求 &#123;&#125; 耗时 &#123;&#125;ms"</span>, exchange.getRequest().getURI().getRawPath(), endTime - startTime);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们自定义了全局过滤器 ElapsedGlobalFilter，并将其注册为 Bean。因为该过滤器优先级最高，所以将其 order 设置为 Ordered.HIGHEST_PRECEDENCE。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/Spring%20Cloud%20Gateway%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/Spring%20Cloud%20Gateway%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Spring Cloud Gateway 工作原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 11:11:00" itemprop="dateCreated datePublished" datetime="2020-02-26T11:11:00+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>Route(路由)：网关的基本构件。它由 ID、目标 URI、Predicates 和 Filters 定义。如果聚合 Predicate 为真，则匹配路由。</li>
<li>Predicate(谓词)：Java 8 Function Predicate。输入类型是一个 Spring Framework ServerWebExchange。它允许开发人员匹配 HTTP 请求中的任何内容，比如 Header 或参数。</li>
<li>Filter(过滤器)：用特定工厂构造的 Spring Framework GatewayFilter 实例。在这里，可以在发送下游请求之前或之后修改请求和响应。</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/images/springcloud/Spring%20Cloud%20Gateway%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Spring Cloud Gateway 工作流程"></p>
<ol>
<li>客户端向 Spring Cloud Gateway 发出请求。</li>
<li>如果 Gateway Handler Mapping 确定请求与某个 Route 匹配，则将其发送给 Gateway Web Handler。</li>
<li>该 Handler 通过特定于请求的 Filter Chain 运行请求。Filters 被虚线分隔的原因是 Filters 可以在发送代理请求之前和之后运行逻辑。执行所有 Pre Filters 逻辑。然后发出代理请求。发出代理请求后，将运行 Post Filters 逻辑。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%BD%91%E5%85%B3/" class="post-title-link" itemprop="url">微服务-网关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 09:29:00" itemprop="dateCreated datePublished" datetime="2020-02-26T09:29:00+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p>
<ul>
<li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li>
<li>存在跨域请求，在一定场景下处理相对复杂。</li>
<li>某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定的困难。</li>
<li>难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。</li>
<li>认证复杂，每个服务都需要独立认证。</li>
</ul>
<p>以上这些问题可以借助网关解决。</p>
<p>网关的角色是作为一个 API 架构，用来保护、增强和控制对于 API 服务的访问。它是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由网关来做，这样既提高业务灵活性又不缺安全性，</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>网关的典型架构图如下图所示：<br><img src="/images/microservice/%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84.webp" alt="网关架构"></p>
<h2 id="四大职能"><a href="#四大职能" class="headerlink" title="四大职能"></a>四大职能</h2><ul>
<li><strong>请求接入：</strong> 作为所有 API 接口服务请求的接入点，管理所有的接入请求。</li>
<li><strong>业务聚合：</strong> 作为多有后端业务服务的聚合点，所有的业务服务都可以在这里被调用。</li>
<li><strong>中介策略：</strong> 实现安全、验证、路由、过滤、流控、缓存等策略，进行一些必要的中介处理。</li>
<li><strong>统一管理：</strong> 提供配置管理工具，对所有 API 服务的调用生命周期和相应的中介策略进行统一管理。</li>
</ul>
<h2 id="分类与功能"><a href="#分类与功能" class="headerlink" title="分类与功能"></a>分类与功能</h2><p>面对互联网复杂的业务系统，基本可以将网关分为两类：流量网关和业务网关。</p>
<ul>
<li><strong>流量网关：</strong> 跟具体的后端业务系统和服务完全无关的部分，比如安全策略、全局性流控策略、流量分发策略等。</li>
<li><strong>业务网关：</strong> 针对具体的后端业务系统，或者是服务和业务有一定关联性的部分，并且一般被直接部署在业务服务的前面。业务网关一般部署在流量网关之后，业务系统之前，比流量网关更靠近系统。我们大部分情况下说的 API 网关，狭义上指的是业务网关。并且如果系统的规模不大，我们也会将两者合二为一，使用一个网关来处理所有的工作。</li>
</ul>
<p><img src="/images/microservice/%E7%BD%91%E5%85%B3%E5%88%86%E7%B1%BB.webp" alt="网关分类"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>单点入口</li>
<li>路由转发</li>
<li>限流熔断</li>
<li>日志监控</li>
<li>安全认证</li>
</ul>
<h2 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h2><ul>
<li>红绿部署</li>
<li>开发者测试分支</li>
<li>埋点测试</li>
<li>压力测试</li>
<li>调试路由</li>
<li>金丝雀测试（粘性）</li>
<li>失败注入测试</li>
<li>降级测试</li>
</ul>
<h2 id="网关-VS-反向代理"><a href="#网关-VS-反向代理" class="headerlink" title="网关 VS 反向代理"></a>网关 VS 反向代理</h2><p>网关提供的基本功能与传统反向代理是大同小异的，不过网关主要是面向 API 和微服务，以提供更灵活的、可以由研发自助（可编程）的的动态配置的能力。</p>
<h2 id="主流开源网关概览"><a href="#主流开源网关概览" class="headerlink" title="主流开源网关概览"></a>主流开源网关概览</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">支持公司</th>
<th align="center">实现语言</th>
<th align="center">亮点</th>
<th align="center">不足</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Nginx(2004)</td>
<td align="center">Nginx Inc</td>
<td align="center">C/Lua</td>
<td align="center">高性能，成熟稳定</td>
<td align="center">门槛高，偏运维，可编程弱</td>
</tr>
<tr>
<td align="center">Kong(2014)</td>
<td align="center">Kong Inc</td>
<td align="center">OpenResty/Lua</td>
<td align="center">高性能，可编程 API</td>
<td align="center">门槛较高</td>
</tr>
<tr>
<td align="center">Zuul1(2012)</td>
<td align="center">Netflix/Pivotal</td>
<td align="center">Java</td>
<td align="center">成熟，简单门槛低</td>
<td align="center">性能一般，可编程一般</td>
</tr>
<tr>
<td align="center">Spring Cloud Gateway(2016)</td>
<td align="center">Pivotal</td>
<td align="center">Java</td>
<td align="center">异步，配置灵活</td>
<td align="center">早期产品</td>
</tr>
<tr>
<td align="center">Envoy(2016)</td>
<td align="center">Lyft</td>
<td align="center">C++</td>
<td align="center">高性能，可编程 API，ServiceMesh 继承</td>
<td align="center">门槛较高</td>
</tr>
<tr>
<td align="center">Traefik(2015)</td>
<td align="center">Containous</td>
<td align="center">Golang</td>
<td align="center">云原生，可编程 API，对接各种服务发现</td>
<td align="center">生产案例不多</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.jianshu.com/p/a2f292221b5c" target="_blank" rel="noopener">微服务网关</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">后端框架-多环境配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-25 20:13:00" itemprop="dateCreated datePublished" datetime="2020-02-25T20:13:00+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">后端框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多环境支持是现代互联网应用研发和交付的一个基本需求，通过规范多环境和对应的研发流程，可以同时提升交付质量和效率。</p>
<h2 id="环境划分"><a href="#环境划分" class="headerlink" title="环境划分"></a>环境划分</h2><p>通常我们会划分以下 4 个环境：</p>
<ul>
<li>dev 环境：开发环境，开发人员使用，版本变动很大。</li>
<li>test 环境：测试环境，测试人员使用，版本相对稳定。</li>
<li>pre 环境：灰度环境，外部用户可以访问，但是服务器配置相对较低，其它和生产环境一样。</li>
<li>pro 环境：生产环境，面向外部用户，连接上互联网即可访问生产环境。</li>
</ul>
<h2 id="配置文件切换"><a href="#配置文件切换" class="headerlink" title="配置文件切换"></a>配置文件切换</h2><p>在 Spring Boot 中，多环境配置文件名需要使用 application-{profile}.yaml 的格式，这里的 <strong>{profile}</strong> 对应的就是是环境标识。<br>比如我们有 dev、test、pre 和 prod 这 4 个环境，那么就可以创建以下 5 个配置文件：</p>
<ul>
<li>application.yaml 存放公共配置</li>
<li>application-dev.yaml</li>
<li>application-test.yaml</li>
<li>application-pre.yaml</li>
<li>application-prod.yaml</li>
</ul>
<p>有 3 种方式可以切换配置文件：</p>
<ul>
<li>在 application.yaml 中指定 <code>spring.profiles.active: dev</code></li>
<li>在执行 java -jar 打包的时候，在后面加上 <code>--spring.profiles.active=dev</code></li>
<li>在 Idea VM options 中设置<code>-Dspring.profiles.active=dev</code></li>
</ul>
<h2 id="配置类切换"><a href="#配置类切换" class="headerlink" title="配置类切换"></a>配置类切换</h2><p>我们还可以使用注解 @Profile，来指定哪些配置类（@Component/@Configuration/@ConfigurationProperties）在哪些环境下生效，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.cnblogs.com/chengkanghua/p/10607239.html" target="_blank" rel="noopener">DEV SIT UAT PET SIM PRD PROD常见环境英文缩写含义</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">后端框架-Swagger 接口文档</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-25 19:06:00" itemprop="dateCreated datePublished" datetime="2020-02-25T19:06:00+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">后端框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>利用<a href="https://springfox.github.io/springfox/" target="_blank" rel="noopener">SpringFox</a>，我们可以很快的将 Swagger 集成到 Spring Boot 项目中。</p>
<h2 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- api doc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启用-Swagger"><a href="#启用-Swagger" class="headerlink" title="启用 Swagger"></a>启用 Swagger</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(SwaggerProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SwaggerProperties swaggerProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwaggerConfig</span><span class="params">(SwaggerProperties swaggerProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.swaggerProperties = swaggerProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(swaggerProperties.getTitle())</span><br><span class="line">                .description(swaggerProperties.getDescription())</span><br><span class="line">                .contact(contact())</span><br><span class="line">                .version(swaggerProperties.getVersion())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Contact <span class="title">contact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contact(swaggerProperties.getContact().getName(),</span><br><span class="line">                swaggerProperties.getContact().getUrl(),</span><br><span class="line">                swaggerProperties.getContact().getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"swagger"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联系人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Contact contact = <span class="keyword">new</span> Contact();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联系人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 名字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 主页</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 邮箱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/static/"</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">"swagger-ui.html"</span>).addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/webjars/**"</span>).addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addResourceHandlers(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>属性配置示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">swagger:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Spring</span> <span class="string">Boot</span> <span class="string">Samples</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">Spring</span> <span class="string">Boot</span> <span class="string">Samples</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1.0</span></span><br><span class="line">  <span class="attr">contact:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cdrcool</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://cdrcool.github.io/</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">cdrcool@163.com</span></span><br></pre></td></tr></table></figure>

<h2 id="Swagger-常用注解"><a href="#Swagger-常用注解" class="headerlink" title="Swagger 常用注解"></a>Swagger 常用注解</h2><ul>
<li>@Api 用于类，说明该类的作用</li>
<li>@ApiOperation 用于方法，说明方法的用途</li>
<li>@ApiImplicitParams 用于方法，包含一组参数说明</li>
<li>@ApiImplicitParam 用于 @ApiImplicitParams 注解中，指定一个参数的配置信息</li>
<li>@ApiResponses 用于方法，包含一组响应说明</li>
<li>@ApiResponse 用于 @ApiResponses 中，指定一个响应的配置信息</li>
<li>@ApiModel 用于类，对类进行说明</li>
<li>@ApiModelProperty 用于类属性或类方法，对类属性进行说明</li>
</ul>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>应用启动后，访问 http://{ip}:{port}/{projectname}/swagger-ui.html 即可查看自动生成的 API 接口文档，JSON 数据可通过接口 http://{ip}:{port}/{projectname}/v2/api-docs 获取。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">后端框架-异步调用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-25 15:08:00" itemprop="dateCreated datePublished" datetime="2020-02-25T15:08:00+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">后端框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Spring 对异步调用提供了良好的支持，只需在启动类上添加注解 @EnableAsync，然后在要执行异步操作的类或方法上添加注解 @Async 即可。</p>
<h2 id="开启异步调用"><a href="#开启异步调用" class="headerlink" title="开启异步调用"></a>开启异步调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WebApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h2><p>@Async 注解既可以添加在类上，也可以添加在方法上，如果是添加在类上，则该类下的所有方法都将被异步执行。<br>如果异步方法有返回值，则需要指定其返回对象类型为 Future。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Execution thread name: &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">executeAndReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Execution thread name: &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"Hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>由于对于 Spring 默认使用代理模式处理 @Async，因此同一类中的本地调用不会被拦截，即 @Async 将会被忽略</strong>。</p>
<h2 id="调用异步任务"><a href="#调用异步任务" class="headerlink" title="调用异步任务"></a>调用异步任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequestMapping</span>((<span class="string">"asyncCall"</span>))</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCallController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AsyncTask asyncTask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncCallController</span><span class="params">(AsyncTask asyncTask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asyncTask = asyncTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"execute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Main thread name: &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        asyncTask.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"executeAndReturn"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">executeAndReturn</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Main thread name: &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = asyncTask.executeAndReturn();</span><br><span class="line">        <span class="comment">// 轮询，直到 future 中有值</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span> future.get();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"Task is working"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h2><p>Spring 会调用由它管理的 Executor 来处理 @Async。如果没有配置 Executor，它会自己创建 SimpleAsyncTaskExecutor。我们可以通过配置参数来调整它的默认配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">    <span class="attr">execution:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">core-size:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">queue-capacity:</span> <span class="number">200</span></span><br><span class="line">        <span class="attr">keep-alive:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">task-</span></span><br></pre></td></tr></table></figure>

<p>我们也可以自定义 Executor，只需要实现类 AsyncConfigurer 并在其方法 getAsyncExecutor() 中返回自定义的 Executor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_EXECUTOR_NAME = <span class="string">"taskExecutor"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskExecutionProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncConfig</span><span class="params">(TaskExecutionProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(ASYNC_EXECUTOR_NAME)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(properties.getPool().getCoreSize());</span><br><span class="line">        executor.setMaxPoolSize(properties.getPool().getMaxSize());</span><br><span class="line">        executor.setQueueCapacity(properties.getPool().getQueueCapacity());</span><br><span class="line">        executor.setKeepAliveSeconds((<span class="keyword">int</span>) properties.getPool().getKeepAlive().getSeconds());</span><br><span class="line">        executor.setThreadNamePrefix(properties.getThreadNamePrefix());</span><br><span class="line">        executor.setTaskDecorator(<span class="keyword">new</span> ContextCopyingDecorator());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要同时配置多个线程池，可以配置多个 Executor Bean。（如果使用了 Spring MVC 中的异步请求，需求将 Executor 的类型设置为 AsyncTaskExecutor）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/" class="post-title-link" itemprop="url">后端框架-异步请求</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-25 11:06:00" itemprop="dateCreated datePublished" datetime="2020-02-25T11:06:00+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">后端框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有些请求业务处理流程可能比较耗时，比如 IO 操作、长查询、远程调用等，主线程会被一直占用，而 Tomcat 线程池线程有限，处理量就会下降。</p>
<p>Servlet 3.0 以后提供了对异步处理的支持，目的就是将容器线程池和业务线程池分离开，将耗时较长的操作移动到业务线程池中进行，释放容器线程，使得容器线程可以处理其他任务，在业务逻辑执行完毕之后，再通知 Tomcat 容器线程池来继续执行后面的操作。</p>
<p>原始模型在处理业务逻辑的过程中会一直占有容器线程池，而异步 Servlet 模型在业务线程池处理的过程中，有一段时间容器线程池中的那个线程是空闲的，这种设计大大提高了容器的处理请求的能力。</p>
<p>Spring MVC 封装了异步处理，满足用户请求后，主线程很快结束，同时开启其它线程处理任务，并将处理结果异步地响应用户，而主线程就可以接收更多请求。</p>
<p>如果要返回单个异步值，可以在 Controller中 返回 Callable、WebAsyncTask 或 DeferredResult，如果要生成多个异步值并将这些值写入响应，则可以在 Controller 中返回 ResponseBodyEmitter、SseEmitter或 StreamingResponseBody。</p>
<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>控制器可以用 Callable 包装任何受支持的返回值。返回值由配置的 TaskExecutor 运行给定的任务来获得。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"callable"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">callable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Main thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"Execution thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello，World!"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebAsyncTask"><a href="#WebAsyncTask" class="headerlink" title="WebAsyncTask"></a>WebAsyncTask</h2><p>如果需要超时处理的回调或者错误处理的回调，可以使用 WebAsyncTask 代替 Callable，它包装了 Callable，功能更强大些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"asyncTask"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">asyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Main thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    WebAsyncTask&lt;String&gt; webAsyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">3000</span>，() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"Execution thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello，World!"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    webAsyncTask.onCompletion(() -&gt; System.out.println(<span class="string">"Finish!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时回调</span></span><br><span class="line">    webAsyncTask.onTimeout(() -&gt; <span class="string">"Time out!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误回调</span></span><br><span class="line">    webAsyncTask.onError(() -&gt; <span class="string">"Error!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> webAsyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a>DeferredResult</h2><p>DeferredResult 使用方式与 Callable 类似，但在返回结果上不一样，它返回的时候实际结果可能还没有生成，实际的结果可能会由另外的线程里面设置到 DeferredResult 中。这个特性非常重要，要实现复杂的功能（比如服务端推技术、订单过期时间处理、长轮询、模拟MQ的功能等等高级应用）都会用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/deferred"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">deferredResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Main thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际应用中，可以由消息队列、定时任务或其它事件触发</span></span><br><span class="line">    CompletableFuture</span><br><span class="line">            .supplyAsync(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"Execution thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Hello，World!"</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .whenCompleteAsync((result，throwable) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 重点：将异步结果赋值到 deferredResult 中</span></span><br><span class="line">                deferredResult.setResult(result);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    deferredResult.onCompletion(() -&gt; log.info(<span class="string">"Finish!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时回调</span></span><br><span class="line">    deferredResult.onTimeout(() -&gt; log.warn(<span class="string">"Time out!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误回调</span></span><br><span class="line">    deferredResult.onError((e) -&gt; log.error(<span class="string">"Error!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然这里有 return，但如果一直没有调用 setResult 设置值，线程就会一直 hold 在这里</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ResponseBodyEmitter"><a href="#ResponseBodyEmitter" class="headerlink" title="ResponseBodyEmitter"></a>ResponseBodyEmitter</h2><p>我们可以使用 ResponseBodyEmitter 返回值来生成对象流，其中每个对象都使用 HttpMessageConverter 序列化并写入响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/emitter"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseBodyEmitter <span class="title">emitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResponseBodyEmitter emitter = <span class="keyword">new</span> ResponseBodyEmitter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程 1 输出</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            emitter.send(<span class="string">"Hello，World!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>，e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程 2 输出</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            emitter.send(<span class="string">"Hello，World again!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>，e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程 3 标记结束</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            emitter.complete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>，e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直阻塞，直到调用 emitter.complete()</span></span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用 ResponseBodyEmitter 作为 ResponseEntity 中的主体，从而自定义响应的状态和标题。</p>
<h2 id="SseEmitter"><a href="#SseEmitter" class="headerlink" title="SseEmitter"></a>SseEmitter</h2><p>SseEmitter (ResponseBodyEmitter 的子类) 提供对服务器发送事件的支持，从服务器发送的事件根据 W3C SSE 规范进行格式化。要从控制器生成 SSE 流，返回 SseEmitter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sseEmitter"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SseEmitter  <span class="title">sseEmitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SseEmitter emitter = <span class="keyword">new</span> SseEmitter ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程 1 输出</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            emitter.send(<span class="string">"Hello，World!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>，e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程 2 输出</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            emitter.send(<span class="string">"Hello，World again!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>，e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程 3 标记结束</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            emitter.complete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error!"</span>，e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直阻塞，直到调用 emitter.complete()</span></span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 SSE 是流媒体到浏览器的主要选项，但请注意 Internet Explorer 不支持服务器发送的事件。考虑使用 Spring 的 WebSocket 消息传递和 SockJS 回退传输(包括 SSE)，这些回退传输针对广泛的浏览器。</p>
<h2 id="StreamingResponseBody"><a href="#StreamingResponseBody" class="headerlink" title="StreamingResponseBody"></a>StreamingResponseBody</h2><p>有时，绕过消息转换并直接将流发送到响应 OutputStream 是很有用的(例如，对于文件下载)。我们可以使用 StreamingResponseBody 返回值类型来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/download"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamingResponseBody <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Main thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> outputStream -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"Execution thread name：&#123;&#125;"</span>，Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// write...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 StreamingResponseBody 作为 ResponseEntity 中的主体来定制响应的状态和标题。</p>
<h2 id="配置-AsyncTaskExecutor"><a href="#配置-AsyncTaskExecutor" class="headerlink" title="配置 AsyncTaskExecutor"></a>配置 AsyncTaskExecutor</h2><p>Spring MVC 执行异步处理需要用到 AsyncTaskExecutor，这个可以在 WebMvcConfigurationSupport.configureAsyncSupport 方法中提供。如果不提供，则使用 SimpleAsyncTaskExecutor，SimpleAsyncTaskExecutor 不使用线程池，因此推荐提供自定义的 AsyncTaskExecutor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebMvcConfig</span><span class="params">(@Qualifier(<span class="string">"applicationTaskExecutor"</span>)</span> Executor executor) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.setTaskExecutor((AsyncTaskExecutor) executor);</span><br><span class="line">        <span class="keyword">super</span>.configureAsyncSupport(configurer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="Servlet-异步处理简述"><a href="#Servlet-异步处理简述" class="headerlink" title="Servlet 异步处理简述"></a>Servlet 异步处理简述</h3><p>可以通过调用 request.startAsync() 将 ServletRequest 设置为异步模式。这样做的主要效果是 Servlet (以及任何过滤器)可以退出，但是响应仍然是开放的，以便稍后完成处理。</p>
<p>对 request.startAsync() 的调用将返回 AsyncContext，我们可以使用它进一步控制异步处理。例如，它提供分派方法，该方法类似于 Servlet API 的转发，只是它允许应用程序在 Servlet 容器线程上恢复请求处理。</p>
<p>ServletRequest 提供对当前 DispatcherType 的访问，我们可以使用它来区分当前处理的是原始请求、异步分发请求、转发或是其他类型的请求分发类型。</p>
<h3 id="Callable-处理流程"><a href="#Callable-处理流程" class="headerlink" title="Callable 处理流程"></a>Callable 处理流程</h3><ul>
<li>Controller 返回一个 Callable。</li>
<li>Spring MVC 调用 request.startAsync() 并将调用提交给 TaskExecutor，以便在单独的线程中进行处理。</li>
<li>同时，DispatcherServlet 和所有过滤器退出 Servlet 容器线程，但是响应保持打开状态。</li>
<li>最后，Callable 产生一个结果，Spring MVC 将请求发送回 Servlet 容器以完成处理。</li>
<li>再次调用 DispatcherServlet，然后处理从 Callable异步生成的返回值。</li>
</ul>
<h3 id="DeferredResult-处理流程"><a href="#DeferredResult-处理流程" class="headerlink" title="DeferredResult 处理流程"></a>DeferredResult 处理流程</h3><ul>
<li>Controller 返回一个 DeferredResult，并将其保存在某个可以访问它的内存队列或列表中。</li>
<li>Spring MVC 调用 request.startAsync()。</li>
<li>同时，DispatcherServlet 和所有配置的过滤器退出请求处理线程，但是响应保持打开状态。</li>
<li>应用程序从某个线程设置 DeferredResult，Spring MVC 将请求发送回 Servlet 容器。</li>
<li>再次调用 DispatcherServlet，然后继续处理异步生成的返回值。</li>
</ul>
<h2 id="对比-WebFlux"><a href="#对比-WebFlux" class="headerlink" title="对比 WebFlux"></a>对比 WebFlux</h2><p>Servlet API 最初是为通过 Filter-Servlet 链进行单次传递而构建的。在 Servlet 3.0 中添加的异步请求处理允许应用程序退出 Filter-Servlet 链，但保持响应以供进一步处理。Spring MVC 异步支持就是围绕这种机制构建的。当 Controller 返回一个 DeferredResult 时，Filter-Servlet 链被退出，Servlet 容器线程被释放。稍后，当设置 DeferredResult 时，将进行异步分发(到相同的 URL)，在此期间将再次映射 Controller，但不是调用它，而是使用 DeferredResult 值(就像 Controller 返回它一样)来恢复处理。</p>
<p>相比之下，Spring WebFlux 既不是基于 Servlet API 构建的，也不需要这样的异步请求处理特性，因为它在设计上就是异步的。异步处理构建在所有框架契约中，并在请求处理的所有阶段得到本质上的支持。</p>
<p>从编程模型的角度来看，Spring MVC 和 Spring WebFlux 都支持异步和 Reactive Types 作为 Controller 方法的返回值。Spring MVC 甚至支持流，包括 reactive back pressure.。但是，对响应的各个写操作仍然是阻塞的(并且是在单独的线程上执行的)，这与 WebFlux 不同，后者依赖于非阻塞 IO，并且每次写操作都不需要额外的线程。</p>
<p>另一个基本区别是，Spring MVC 在 Controller 方法参数中不支持异步或 reactive types(例如，@RequestBody、@RequestPart等)，也不支持将异步和响应类型作为模型属性。而 Spring WebFlux 却支持所有这些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-DTO%E4%B8%8EDMO%E4%BA%92%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/24/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-DTO%E4%B8%8EDMO%E4%BA%92%E8%BD%AC/" class="post-title-link" itemprop="url">后端框架-DTO 与 DMO 互转</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-24 21:54:00" itemprop="dateCreated datePublished" datetime="2020-02-24T21:54:00+08:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">后端框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>DTO 数据传输对象</li>
<li>DMO 数据模型对象</li>
</ul>
<p>大多数情况下，DTO 与 DMO 所承载的字段大致是一样的，但是有些时候也会有差别。比如某些情况下，DTO 可能根据会实际需要裁剪或聚合添加某些字段，另外对于不同的 API 接口场景，即使使用同一个 DTO，它们的校验方式也可能不同。因此对于同一个 DMO，我们可能会用到一个或多个 DTO，那么为了交换数据，必然会存在两者之间的转换，也就是数据字段的拷贝。这种拷贝如果手工去做，繁琐且容易出错，好在业界有一些实践，可以帮我们自动处理绝大多数场景下的字段映射。（少数特殊场景下，有些字段可能不能自动匹配映射，只需要简单的定制一些映射逻辑即可）</p>
<h2 id="ModelMapper"><a href="#ModelMapper" class="headerlink" title="ModelMapper"></a>ModelMapper</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.modelmapper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modelmapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;modelmapper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ModelMapper modelMapper = <span class="keyword">new</span> ModelMapper();</span><br><span class="line">OrderDto order = modelMapper.map(orderEntity, OrderDto<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="MapStruct"><a href="#MapStruct" class="headerlink" title="MapStruct"></a>MapStruct</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">OrderDto <span class="title">toDto</span><span class="params">(OrderEntity entity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">OrderEntity <span class="title">toEntity</span><span class="params">(OrderDto dto)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OrderMapper mapper = Mappers.getMapper(OrderMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">OrderDto order = mapper.convert(orderEntity);</span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul>
<li>ModelMapper 是在运行期使用反射，而 MapStruct 是在编译期动态生成字节码</li>
<li>MapStruct 性能远高于 ModelMapper</li>
<li>ModelMapper 易用性高于 MapStruct</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">晴天</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">199</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">晴天</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
