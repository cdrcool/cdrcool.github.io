<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="OnePiece">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="OnePiece">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="晴天">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>OnePiece</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">OnePiece</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">人的知识就好比一个圆圈，圆圈里面是已知的，圆圈外面是未知的。你知道得越多，圆圈也就越大，你不知道的也就越多。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">第三方开放平台登录授权设计与实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-06 15:00:00" itemprop="dateCreated datePublished" datetime="2020-05-06T15:00:00+08:00">2020-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 15:28:11" itemprop="dateModified" datetime="2021-05-07T15:28:11+08:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">架构设计</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h1><h2 id="公司信息表"><a href="#公司信息表" class="headerlink" title="公司信息表"></a>公司信息表</h2><table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">字段描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">company_name</td>
<td align="left">公司名称</td>
</tr>
<tr>
<td align="left">taxpayer_id</td>
<td align="left">纳税人识别号</td>
</tr>
<tr>
<td align="left">company_phone</td>
<td align="left">公司电话</td>
</tr>
<tr>
<td align="left">company_registered_address</td>
<td align="left">公司注册地址</td>
</tr>
<tr>
<td align="left">bank_name</td>
<td align="left">开户行名称</td>
</tr>
<tr>
<td align="left">bank_account</td>
<td align="left">开户行账号</td>
</tr>
<tr>
<td align="left">jd_account</td>
<td align="left">京东账号名</td>
</tr>
<tr>
<td align="left">sn_account</td>
<td align="left">苏宁账号名</td>
</tr>
</tbody></table>
<h2 id="第三方账号表"><a href="#第三方账号表" class="headerlink" title="第三方账号表"></a>第三方账号表</h2><table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">字段描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">account_type</td>
<td align="left">账号类型（jd-京东；sn-苏宁）</td>
</tr>
<tr>
<td align="left">account</td>
<td align="left">账号名</td>
</tr>
<tr>
<td align="left">password</td>
<td align="left">账号密码</td>
</tr>
<tr>
<td align="left">access_token</td>
<td align="left">访问令牌</td>
</tr>
<tr>
<td align="left">refresh_token</td>
<td align="left">刷新令牌</td>
</tr>
<tr>
<td align="left">access_token_expires_at</td>
<td align="left">访问令牌过期时间</td>
</tr>
<tr>
<td align="left">refresh_token_expires_at</td>
<td align="left">刷新令牌过期时间</td>
</tr>
<tr>
<td align="left">sn_account</td>
<td align="left">苏宁账号名</td>
</tr>
</tbody></table>
<p>在第三方账号表里的账号，都是子账号，总账号信息保存在配置文件中（也可以保存在数据库里），如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sdk:</span></span><br><span class="line">  <span class="attr">accounts:</span></span><br><span class="line">    <span class="attr">jd:</span></span><br><span class="line">      <span class="attr">auth-url:</span></span><br><span class="line">      <span class="attr">server-url:</span></span><br><span class="line">      <span class="attr">account:</span> </span><br><span class="line">      <span class="attr">password:</span></span><br><span class="line">      <span class="attr">app-key:</span></span><br><span class="line">      <span class="attr">app-secret:</span></span><br><span class="line">      <span class="attr">redirect-uri:</span></span><br><span class="line">      <span class="attr">rsa-key:</span></span><br><span class="line">    <span class="attr">sn:</span></span><br><span class="line">      <span class="attr">auth-url:</span></span><br><span class="line">      <span class="attr">server-url:</span></span><br><span class="line">      <span class="attr">account:</span></span><br><span class="line">      <span class="attr">password:</span></span><br><span class="line">      <span class="attr">app-key:</span></span><br><span class="line">      <span class="attr">app-secret:</span></span><br><span class="line">      <span class="attr">redirect-uri:</span></span><br><span class="line">      <span class="attr">rsa-key:</span></span><br></pre></td></tr></table></figure>
<p>除了账号名和账号密码之外，其他信息子账号与主账号相同。</p>
<h1 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h1><h2 id="请求第三方token"><a href="#请求第三方token" class="headerlink" title="请求第三方token"></a>请求第三方token</h2><p><strong>请求地址</strong>：POST /{account-type}-account/request-access-token</p>
<p><strong>请求参数</strong>：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">taxpayerId</td>
<td align="left">纳税人识别号</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">超时时间（单位：秒），默认值 3</td>
</tr>
</tbody></table>
<p>如果未传递 taxpayerId，则请求默认的第三方token；如果在指定时间内，第三方未返回token，则抛出错误提示：请求第三方token超时。</p>
<p><strong>请求响应</strong>：token字符串</p>
<h2 id="第三方回调地址"><a href="#第三方回调地址" class="headerlink" title="第三方回调地址"></a>第三方回调地址</h2><p>调用请求第三方token接口后，由第三方回调该接口。</p>
<p><strong>请求地址</strong>：GET /{account-type}-account/callback-token</p>
<p><strong>请求参数</strong>：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">code</td>
<td align="left">第三方返回的鉴权码</td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">由client使用的不透明参数，用于请求阶段和回调阶段之间的状态保持</td>
</tr>
</tbody></table>
<p><strong>请求响应</strong>：token字符串</p>
<h2 id="刷新第三方token"><a href="#刷新第三方token" class="headerlink" title="刷新第三方token"></a>刷新第三方token</h2><p><strong>请求地址</strong>：POST /{account-type}-account/refresh-token</p>
<p><strong>请求参数</strong>：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">taxpayerId</td>
<td align="left">纳税人识别号</td>
</tr>
</tbody></table>
<p>如果未传递 taxpayerId，则请求默认的第三方token。</p>
<p><strong>请求响应</strong>：token字符串</p>
<h2 id="获取第三方token"><a href="#获取第三方token" class="headerlink" title="获取第三方token"></a>获取第三方token</h2><p><strong>请求地址</strong>：POST /{account-type}-account/get-access-token</p>
<p><strong>请求参数</strong>：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">taxpayerId</td>
<td align="left">纳税人识别号</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">超时时间（单位：秒），默认值 3</td>
</tr>
</tbody></table>
<p>如果未传递 taxpayerId，则请求默认的第三方token；如果在指定时间内，未返回第三方token，则抛出错误提示：获取第三方token超时。</p>
<p><strong>请求响应</strong>：token字符串</p>
<h2 id="初始化所有的第三方token"><a href="#初始化所有的第三方token" class="headerlink" title="初始化所有的第三方token"></a>初始化所有的第三方token</h2><p><strong>请求地址</strong>：POST /{account-type}-account/init-all-token</p>
<h2 id="刷新所有的第三方token"><a href="#刷新所有的第三方token" class="headerlink" title="刷新所有的第三方token"></a>刷新所有的第三方token</h2><p><strong>请求地址</strong>：POST /{account-type}-account/refresh-all-token</p>
<h1 id="接口实现-UML类图"><a href="#接口实现-UML类图" class="headerlink" title="接口实现-UML类图"></a>接口实现-UML类图</h1><p><img src="/images/architecture/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0UML%E7%B1%BB%E5%9B%BE.png" alt="接口实现UML类图"></p>
<ul>
<li>ThirdAccountController：第三方账号 Controller 抽象类</li>
<li>JdAccountController：京东账号 Controller 实现类，注入京东账号 Service</li>
<li>SnAccountController：苏宁账号 Controller 实现类，注入苏宁账号 Service</li>
<li>ThirdAccountService：第三方账号 Service 抽象类</li>
<li>JdAccountService：京东账号 Service 实现类</li>
<li>SnAccountService：苏宁账号 Service 实现类</li>
</ul>
<h1 id="Token-请求流程"><a href="#Token-请求流程" class="headerlink" title="Token 请求流程"></a>Token 请求流程</h1><p><img src="/images/architecture/%E7%AC%AC%E4%B8%89%E6%96%B9token%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png" alt="第三方token请求流程"></p>
<h1 id="Token-定时刷新"><a href="#Token-定时刷新" class="headerlink" title="Token 定时刷新"></a>Token 定时刷新</h1><p>每天凌晨（可配置）自动刷新所有第三方账号的token。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三方token刷新定时任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cdrcool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdTokenRefreshTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ThirdAccountService&gt; thirdAccountServices;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThirdTokenRefreshTask</span><span class="params">(Map&lt;String, ThirdAccountService&gt; thirdAccountServices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.thirdAccountServices = thirdAccountServices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"$&#123;sdk.accounts.refresh-token-cron&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        thirdAccountServices.values().forEach(thirdAccountService -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thirdAccountService.refreshAllToken();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"定时刷新第三方token异常，class name：&#123;&#125;"</span>, thirdAccountService.getClass().getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sdk:</span></span><br><span class="line">  <span class="attr">accounts:</span></span><br><span class="line">    <span class="attr">refresh-token-cron:</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="string">*</span> <span class="string">*</span> <span class="string">?</span></span><br></pre></td></tr></table></figure>

<h1 id="异步返回-Token"><a href="#异步返回-Token" class="headerlink" title="异步返回 Token"></a>异步返回 Token</h1><p>使用<code>DeferredResult</code>（异步 Servlet）来异步返回 token。<br>在<code>DeferredResult</code>未拿到返回数据之前，<code>DispatcherServlet</code>和所有的<code>Filter</code>会退出<code>Servlet</code>容器线程并释放其资源，同时也允许容器去处理其它请求，但响应保持打开状态。 一旦<code>DeferredResult</code>拿到返回数据，<code>DispatcherServlet</code>会被再次调用并处理，以异步产生的方式，向请求端返回值。这么做的好处就是请求不会长时间占用容器连接池，提高服务器的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三方帐号 Controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cdrcool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdAccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"请求第三方token（未传递纳税人识别号，则请求的默认第三方token）"</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/request-access-token"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">requestAccessToken</span><span class="params">(@ApiParam(<span class="string">"纳税人识别号"</span>)</span> String taxpayerId,</span></span><br><span class="line"><span class="function">                                                     @<span class="title">ApiParam</span><span class="params">(value = <span class="string">"超时时间（单位：秒）"</span>, defaultValue = <span class="string">"3"</span>)</span></span></span><br><span class="line"><span class="function">                                                     @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"3"</span>)</span> Integer timeout) </span>&#123;</span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;(timeout.longValue() * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求第三方token</span></span><br><span class="line">        thirdAccountService.requestAccessToken(taxpayerId, deferredResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时回调</span></span><br><span class="line">        deferredResult.onTimeout(() -&gt; deferredResult.setErrorResult(<span class="string">"请求第三方token超时，请稍后重试"</span>));</span><br><span class="line">        <span class="comment">// 失败回调</span></span><br><span class="line">        deferredResult.onError(e -&gt; deferredResult.setErrorResult(<span class="string">"请求第三方token异常："</span> + e.getMessage()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待第三方回调应用 callback-token 接口，在 callback-token 接口里获取到token之后，再调用 deferredResult.setResult(token)</span></span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Oauth-2-0-state-参数"><a href="#Oauth-2-0-state-参数" class="headerlink" title="Oauth 2.0 state 参数"></a>Oauth 2.0 state 参数</h1><p>在请求第三方code时，还需要传递state参数，它是由client使用的不透明参数，用于请求阶段和回调阶段之间的状态保持。请求示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;open-oauth.jd.com&#x2F;oauth2&#x2F;authorizeForVOP?app_key&#x3D;xxx&amp;redirect_uri&#x3D;xxx&amp;username&#x3D;xxx&amp;password&#x3D;xxx&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_base&amp;state&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p>state可以是一个随机字符串，然后保存在内存里，回调时检查state参数和内存里的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三方帐号 Service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cdrcool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, TokenRequestInfo&gt; STORE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求第三方token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taxpayerId     纳税人识别号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deferredResult &#123;<span class="doctag">@link</span> DeferredResult&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestAccessToken</span><span class="params">(String taxpayerId, DeferredResult&lt;String&gt; deferredResult)</span> </span>&#123;</span><br><span class="line">        ThirdAccount thirdAccount = getThirdAccount(taxpayerId);</span><br><span class="line">        String state = UUID.randomUUID().toString();</span><br><span class="line">        requestAccessToken(thirdAccount, state);</span><br><span class="line"></span><br><span class="line">        TokenRequestInfo tokenRequestInfo = <span class="keyword">new</span> TokenRequestInfo(state, accountType(), thirdAccount.getAccount());</span><br><span class="line">        <span class="comment">// 保存当前请求的deferredResult，在token回调成功后对其setResult</span></span><br><span class="line">        tokenRequestInfo.setDeferredResult(deferredResult);</span><br><span class="line">        STORE.put(state, tokenRequestInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第三方token回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code  授权码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 回传state（与传递给第三方的state一致）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callbackToken</span><span class="params">(String code, String state)</span> </span>&#123;</span><br><span class="line">        TokenResponse response = getTokenResponse(code);</span><br><span class="line"></span><br><span class="line">        TokenRequestInfo tokenRequestInfo = STORE.get(state);</span><br><span class="line">        <span class="keyword">if</span> (tokenRequestInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"未找到与state：&#123;&#125;对应的token请求信息："</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"找到state：&#123;&#125;对应的京东帐号：&#123;&#125;"</span>, state, tokenRequestInfo.getAccount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将京东帐号及其对应的token存到redis缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(tokenRequestInfo.getAccount(), response.getAccessToken());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找京东帐号，并更新其对应的token响应</span></span><br><span class="line">        LambdaQueryWrapper&lt;ThirdAccount&gt; jdAccountWrapper = Wrappers.lambdaQuery();</span><br><span class="line">        jdAccountWrapper.eq(ThirdAccount::getAccount, tokenRequestInfo.getAccount());</span><br><span class="line">        ThirdAccount thirdAccount = thirdAccountMapper.selectOne(jdAccountWrapper);</span><br><span class="line">        <span class="keyword">if</span> (thirdAccount == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"未找到京东帐号："</span> + tokenRequestInfo.getAccount());</span><br><span class="line">        &#125;</span><br><span class="line">        thirdAccount.setAccessToken(response.getAccessToken());</span><br><span class="line">        thirdAccount.setRefreshToken(response.getRefreshToken());</span><br><span class="line">        thirdAccount.setAccessTokenExpiresAt(response.getTime() + response.getExpiresIn());</span><br><span class="line">        thirdAccount.setRefreshTokenExpiresAt(response.getTime() + response.getRefreshTokenExpires());</span><br><span class="line">        thirdAccountMapper.updateById(thirdAccount);</span><br><span class="line"></span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = tokenRequestInfo.getDeferredResult();</span><br><span class="line">        <span class="keyword">if</span> (deferredResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将token设置到deferredResult里</span></span><br><span class="line">            deferredResult.setResult(response.getAccessToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深入理解Java虚拟机-线程安全与锁优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 18:25:00" itemprop="dateCreated datePublished" datetime="2020-04-12T18:25:00+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>可以将 Java 语言中各种操作共享的数据分为以下五类：</p>
<ul>
<li>不可变</li>
<li>绝对线程安全</li>
<li>相对线程安全</li>
<li>线程兼容</li>
<li>线程对立</li>
</ul>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><ul>
<li>互斥同步</li>
<li>非阻塞同步</li>
<li>无同步方案</li>
</ul>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器上有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋。</p>
<p>自旋等待不能替换阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但是它是要占用处理器的时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。</p>
<p>JDK6 引入了自适应的自旋，自适应意味着自旋的时间不再是固定的（10 此）了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在用一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能再次成功，进而允许自选等待持续相对更长的时间，比如持续 100 次循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃出去被其他线程访问，那就可以把它们当作栈上的数据对待，认为它们是线程私有的，同步加锁自然就无需再进行。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果虚拟机探测到存在零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过，需要强调一点，轻量级锁并不是用来替代重量级锁的，它设计的初衷是在没有多线陈竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不去做了。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（TradeOff）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。</p>
<p>偏向锁无法使用自旋锁优化，因为一旦有其它线程申请锁，就破坏了偏向锁的的假定。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景：</p>
<ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li>
<li>重量级锁：有实际竞争，且锁竞争时间长。</li>
</ul>
<p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.jianshu.com/p/36eedeb3f912" target="_blank" rel="noopener">浅谈偏向锁、轻量级锁、重量级锁</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">深入理解Java虚拟机-类加载机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 10:00:00" itemprop="dateCreated datePublished" datetime="2020-04-12T10:00:00+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在 Java 里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态扩展和动态连接这个特点实现的。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备和解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示：</p>
<p><img src="/images/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.jpeg" alt="类加载顺序"></p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序时确定的，类型的记载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这时为了支持 Java 的运行时绑定特性（也称为动态绑定或晚期绑定）。注意，这些阶段通常都是互相交叉的混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，Java 虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取这个类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段的目的是确保 Class 文件的字节流中包含的信息符符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了 Java 虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。</p>
<p>从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类型定义的变量（即静态变量，被 static 修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在 JDK7 之前，HotSpot 使用永久代来实现方法区时，实现是完全符合这种概念的；而在 JDK8 之后，类变量会随着 Class 对象一起存放在 Java 堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
<p>关于准备阶段，还有两个容易混淆的概念需要着重强调，首先这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象的初始化时随着对象一起分配在 Java 堆中。其次是这里所说的初始值“通常情况下”是数据类型的零值。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>前面介绍的几个加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由 Java 虚拟机来主导控制。直到初始化阶段，Java 虚拟机才真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。</p>
<p>初始化阶段就是执行类构造器 <clinit>() 方法的过程。</p>
<ul>
<li><p><clinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中智能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态教育局快可以赋值，但是不能访问。</p>
</li>
<li><p><clinit>() 方法与类的构造函数不同，它不需要显示地调用父类构造器，Java 虚拟机会保证在子类地 <clinit>() 方法执行前，父类的 <clinit>() 方法已经执行完毕。因此在 Java 虚拟机中第一个被执行的 <clinit>() 方法的类的类型肯定是 java.lang.Object。</p>
</li>
<li><p>由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块要由于子类的变量赋值操作。</p>
</li>
<li><p><clinit>() 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然由变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。</p>
</li>
<li><p>Java 虚拟机必须保证一个类的 <clinit>() 方法在多线程环境中被正确的加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 <clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行完毕 <clinit>() 方法。</p>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java 虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="/images/java/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="双亲委派模型"></p>
<p> 在 JDK9 之前，Java 应用都是由启动类加载器、扩展类加载器、应用程序类加载器这三类加载器互相配合来完成加载的，如果用户认为有必要，还可以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的 Class 文件来源，或者通过类加载器实现类的隔离、重载等功能。</p>
<p> 双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p> 类加载器之间的父子关系一般不是以集成（Inheritance）的关系实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p> 使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载环境中都能够保证是同一个类。</p>
<h2 id="Java-模块化系统"><a href="#Java-模块化系统" class="headerlink" title="Java 模块化系统"></a>Java 模块化系统</h2><p> 在 JDK9 中引入了 Java 模块系统（Java Platform Module Systemm, JPMS），它是为了能够实现模块化的关键目标——可配置的封装隔离机制。JDK9 的模块不仅仅像之前的 JAR 包那样只是简单地充当代码地容器，除了代码外，Java 的模块定义还包括以下内容：</p>
<ul>
<li><p>依赖其他模块的列表。</p>
</li>
<li><p>导出的包列表，即其他模块可以使用的列表。</p>
</li>
<li><p>开放的包列表，即其他模块可反射访问模块的列表。</p>
</li>
<li><p>使用的服务了列表。</p>
</li>
<li><p>提供服务的实现列表。</p>
<p>为了保证兼容性，JDK9 并没有从根本上动摇从 JDK 1.2 以来运行了二十年之久的三层类加载结构以及双亲委派模型。但是为了模块化系统的顺利实施，模块下的类加载器仍然发生了一些应该被注意到的变动，主要包括以下几个方面。</p>
<p>首先，是扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。</p>
<p>其次，平台类加载器和应用程序类加载器都不再派生自 java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全部继承于 jdk.internal.loader.BuiltinClassLoader，在 BuiltinClassLoader 中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问行的处理。</p>
<p>另外，启动类加载器现在是 Java 虚拟机内部和 Java 类库共同协作实现的类加载器，尽管有了 BootClassLoader 这样的 Java 类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如 Object.class.getClassLoader()）中仍然会返回 null 代替，而不会得到 BootClassLoader 的实例。</p>
<p>最后，JDK9 中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
</li>
</ul>
<p><img src="/images/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="类加载器"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">深入理解Java虚拟机-内存模型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-11 12:32:00" itemprop="dateCreated datePublished" datetime="2020-04-11T12:32:00+08:00">2020-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需通过主内存来完成，线程、主内存、工作内存三者交互关系如下图所示：</p>
<p><img src="/images/java/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.webp" alt="内存模型"></p>
<p>这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。如果一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储与寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。</p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java 内存模型中定义了以下 8 种操作，Java 虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外）。</p>
<ul>
<li>lock（锁定）</li>
<li>unlock（解锁）</li>
<li>read（读取）</li>
<li>load（载入）</li>
<li>use（使用）</li>
<li>assign（赋值）</li>
<li>store（存储）</li>
<li>write（写入）</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要按顺序执行 store 和 write 操作。注意，Java 内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。</p>
<h2 id="volatile-型变量的特殊规则"><a href="#volatile-型变量的特殊规则" class="headerlink" title="volatile 型变量的特殊规则"></a>volatile 型变量的特殊规则</h2><p>当一个变量被定义成 volatile 之后，它将具备两项特性：第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</p>
<p>需要说明的是，基于 volatile 变量的运算并不能保证在并发下一定是线程安全的，在不符合以下两条规则的运算场景中，仍然要通过加锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的胡藏太变量共同参与不变约束。</li>
</ul>
<p>使用 volatile 变量的第二个语义是禁止指令重排序优化。</p>
<h2 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h2><ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，比如说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括了修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>下面是 Java 内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。</p>
<ul>
<li><p>程序次序原则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
</li>
<li><p>管程锁定原则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
</li>
<li><p>volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
</li>
<li><p>线程启动规则（Thread Start Rule）：Thread 对象的 start 方法先行发生于此线程的每一个动作。</p>
</li>
<li><p>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测。</p>
</li>
<li><p>线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</p>
</li>
<li><p>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
</li>
<li><p>传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于 操作 C 的结论。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">深入理解Java虚拟机-垃圾收集器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-11 10:55:00" itemprop="dateCreated datePublished" datetime="2020-04-11T10:55:00+08:00">2020-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>垃圾收集器主要是关注 Java 堆和方法区这两个区域的内存管理。</p>
<h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><p>在堆里面存放着 Java 世界中几乎所有地对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用过它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不能再被使用的。</p>
<p>客观地说，引用计数法（Reference Counting）虽然占用了一些额外地内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的选择。</p>
<p>但是，在 Java 领域，至少主流的 Java 虚拟机里面都没有选用引用计数法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯地引用计数就很难解决对象之间相互循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>当前主流的商用程序语言（Java、C#，上溯至古老的 Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中 JNI （即通常所说的 Native 方法）引用的对象。</li>
<li>Java 虚拟机内部的引用，如基本数据类型对象的 Class 对象，一些常驻的异常对象（比如 NullPointException、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized 关键字）持有的对象。</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li>
</ul>
<p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。譬如分代收集和局部回收（Partial GC），如果只针对 Java 堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入 GC Roots 集合中去，才能保证可达性分析的正确性。</p>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。</p>
<p>在 JDK 1.2 版之后，Java 堆引用的概念进行了扩充，将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Week Reference）和虚引用（Phantom Reference） 4 种，这 4 种引用强度依次逐渐减弱。</p>
<ul>
<li><p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用时用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 版本之后提供了 SoftReference 类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在 JDK 1.2 版本之后提供了 WeakReference 类来实现弱引用。</p>
</li>
<li><p>虚引用也称为“虚灵引用”或者“幻影引用”，它时最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
</li>
</ul>
<h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>即使在可达性分析算法种判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都是为“没有必要执行”。</p>
<p>如果这个对象被判定为确有必要执行 finalize() 方法，那么该对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalize 线程去执行它们的 finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的 finalize() 方法执行缓慢，或者更极端地发生了死循环，将很可能导致 F-Queue 队列中地其他对象永久处于等待，甚至导致整个内存回收子系统地崩溃。</p>
<p>由于 finalize() 方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用语法。finalize() 能做的所有工作，使用 try-finally 或者其他方式都可以做得更好、更及时。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>从如何判定对象消亡地角度触发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。由于引用计数式垃圾收集算法在主流 Java 虚拟机中均未设计，所以本节介绍的所有算法均属于追踪式垃圾收集的范畴。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</p>
<p>把 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minnor GC”、“Major GC”、“Full GC”这样的回收类型的划分；也才能够针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”、“标记-清除算法”、“标记-整理算法”等针对性的垃圾收集算法。</p>
<p>需要强调的是，分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。</p>
<p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p>
<ol start="3">
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说进占极少数。</li>
</ol>
<p>这其实是可根据前两条假说逻辑推理得出的隐含结论：存在互相引用关系的两个对象是应该倾向于同时生寸或者同时消亡的。</p>
<p>依据这条假说，我们就只需在新生代上建立一个全局的数据结构（该结构被成为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）。如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<p>之所以说它是最基础的收集算法，是因为后续的收集算法大多是以标记-清除算法为基础，对其缺点进行改进而得到的。它的主要缺点有两个：第一个是执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随着对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p>标记-清除算法的执行过程如下图所示：<br><img src="/images/java/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法"></p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969 年 Fenichel 提出了一种称为“半区复制”（Semispace Coping）的垃圾收集算法，它将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行搞笑，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p>
<p>标记-复制算法的执行过程如下图所示：<br><img src="/images/java/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="标记-复制算法"></p>
<p>在 1989 年，Andrew Appel 针对具有“朝生熄灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Apple 式回收”。HotSpot 虚拟机的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局。Apple 式回收的具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外的一块 Survivor 空间上，然后直接清理 Eden 和已用过的那块 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也即每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间，即 10% 的新生代是会被“浪费”的。当然，任何人都没有办法百分百保证每次回收都只有不多于 10% 的对象存活，因此 Appel 式回收还有以后个充当罕见情况的“逃生门”的安全设计，当 Survivor 空间不足以容纳一次 Minnor GC 之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性地“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p>标记-整理算法的执行过程如下图所示：<br><img src="/images/java/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法"></p>
<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。</p>
<p>另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经达到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。CMS 收集器面临空间碎片过多时采用的就是这种处理办法。</p>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p><img src="/images/java/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="HotSpot 虚拟机的垃圾收集器"></p>
<p>上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial 收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集巩工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p>Serial 收集器是 HotSpot 虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p>![Serial-Serial Old收集器运行示意图](/images/java/Serial-Serial Old收集器运行示意图.webp)</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<p>自 JDK9 开始，ParNew 加 CMS 收集器的组合不再是官方推荐的服务器端模式下的收集器解决方案。官方希望它能完全被 G1 所取代。在不久以后，ParNew 会合并入 CMS，称为它专门处理新生代的组成部分。ParNew 可以说是 HotSport 虚拟机中第一款退出历史舞台的垃圾收集器。</p>
<p>![ParNew-Serial Old收集器运行示意图](/images/java/ParNew-Serial Old收集器运行示意图.webp)</p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。</p>
<p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行代码的时间与处理器总消耗的时间的比值，即：吞吐量 = 运行用户代码时间/（运行用户代码时间 + 运行垃圾收集时间）。</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的 HotSpot 虚拟机使用。</p>
<p>![Serial-Serial Old收集器运行示意图](/images/java/Serial-Serial Old收集器运行示意图.webp)</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p>
<p>直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。</p>
<p>![Parallel Scavenge-Paraller Old收集器运行示意图](/images/java/Parallel Scavenge-Paraller Old收集器运行示意图.webp)</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p>CMS 是一款优秀的收集器，它最主要的优点在名字上已经体现出来：并发收集、低停顿，但是它至少有以下三个明显的缺点：</p>
<ol>
<li>首先，CMS 收集器对处理器资源非常敏感。</li>
<li>然后，由于 CMS 收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent Mode Failure”失败而导致另一次完全“Stop The World”的 Full GC 的产生。</li>
<li>最后，由于 CMS 是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。</li>
</ol>
<h3 id="Garbage-First-收集器"><a href="#Garbage-First-收集器" class="headerlink" title="Garbage First 收集器"></a>Garbage First 收集器</h3><p>同之前的收集器不同，G1 收集器垃圾收集的范围不再是整个新生代（Minor GC），或整个老年代（Major GC），又或整个 Java 堆（Full GC），而是面向堆内存任何部分来组成回收集（Collection Set，一般简称 CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed GC 模式。</p>
<p>G1 开创的基于 Region 的堆内存布局是它能够实现这个目标的关键。虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p>
<p>Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。G1 认为只要大小超过了一个 Region 容量一般的对象即可判定为大对象。每个 Region 的大小可以通过参数设定，取值范围为 1MB ~ 32MB，且应为 2 的 N 次幂。而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 Humongous Region 之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。</p>
<p>虽然 G1 仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1 收集器之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个 Java 队中进行全区域的垃圾手机。更具体地处理思路是让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些 Region，这也就是 “Garbage First”名字的由来。</p>
<p><img src="/images/java/G1%E6%94%B6%E9%9B%86%E5%99%A8.webp" alt="G1 收集器"></p>
<h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><p>衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。三者总体的表现会随计数进步而越来越好，但是要在这三个方面同时具有卓越表现的“完美”收集器是极其困难甚至是不可能的，一款优秀的收集器通常最多可以同时达成其中的两项。</p>
<p>在内存占用、吞吐量和延迟这三项指标里，延迟的重要性日益凸显，越发备受关注。</p>
<h3 id="Shenandoah-收集器"><a href="#Shenandoah-收集器" class="headerlink" title="Shenandoah 收集器"></a>Shenandoah 收集器</h3><h3 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h3><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul>
<li>对象优先在 Eden 分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代</li>
<li>动态对象年龄判定</li>
<li>空间分配担保</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/" class="post-title-link" itemprop="url">深入理解Java虚拟机-运行时数据区域</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-11 09:12:00" itemprop="dateCreated datePublished" datetime="2020-04-11T09:12:00+08:00">2020-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动一致存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：</p>
<p><img src="/images/java/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="运行时数据区域"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指令器。在 Java 虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功都需要依赖这个计数器来完成。</p>
<p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器的值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机栈所允许的深度，将抛出 StackOverflowError 异常；如果 Java 虚拟机栈容量可以动态扩展，但扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<p>有的虚拟机（譬如 HotSpot 虚拟机）直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者扩展失败时分别抛出 StackOverflowError 和 OutOfMemorError 异常。</p>
<h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>对于 Java 应用程序来说，Java 堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p>
<p>由于即时编译技术的进步，尤其是逃逸分析技术的日益强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，以及日后可能出现值类型的支持，所以说 Java 对象实例都分配在对上也渐渐变得不是那么绝对了。</p>
<p>Java 堆既可以被是现成固定大小的，也可以是可扩展的，不过当前主流的 Java 虚拟机都是按照可扩展来实现的（通过参数 -Xmx 和 -Xms 设定）。如果在Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述成堆的一个逻辑部分，但是它有一个别名叫做“非堆”（Non-Heap），目的是与 Java 堆区分开来。</p>
<p>在 JDK8 之前，Java 虚拟机使用永久代来实现方法区，到了 JDK 8，已经完全废弃了永久代的概念，改用在本地内存中实现的元空间（Meta space）来代替。</p>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少见的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个取悦的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是有必要的。</p>
<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时将抛出 OutOfMemoryError 异常。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<p>需要特别注意的是，运行时常量池和字符串常量池的区别，在 JDK7 之前，运行时常量池逻辑包含字符串常量池存放在方法区，此时 HotSpot 虚拟机对方法区的实现为永久代。在 JDK7 字符串常量池被从方法区拿到了堆中，运行时常量池剩下的东西还在方法区, 也就是 HotSpot 中的永久代。JDK8 HotSpot 移除了永久代引入元空间, 这时候字符串常量池还在堆中, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。</p>
<p>显然，本机直接内存地分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机内存（包括物理内存、SWAP 分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 -Xmx 等参数信息，但经常忽略掉直接内存，是的各个内存区域综合大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">后端框架-远程调试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 21:46:00" itemprop="dateCreated datePublished" datetime="2020-04-07T21:46:00+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">后端框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>方式一：命令启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,<span class="built_in">suspend</span>=n -jar target/springboot-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-Xdebug：表示项目工作在 debug 的模式下。</li>
<li>address=8000：开放 8000 作为调试端口。</li>
<li>server=y：表示在远程 Debug 会话的过程中作为服务端。</li>
<li>suspend=y：表示在客户端建立连接前，服务端被挂起；=n 则不会被挂起。 专门调试时建议设置成 y。</li>
</ul>
<p>方式二：配置 Maven Plugin</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Package as an executable jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">                -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000</span><br><span class="line">            <span class="tag">&lt;/<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后进行打包 mvn package，在项目的根路径下面启动项目，使用命令 mvn spring-boot。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/06/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">JVM 性能监控与调优</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 13:44:00" itemprop="dateCreated datePublished" datetime="2020-04-06T13:44:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h2><h3 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h3><p>在 JVM 各版本中基本不变，相对稳定。</p>
<ul>
<li>-help</li>
<li>-server -client</li>
<li>-version -showversion</li>
<li>-cp -classpath</li>
</ul>
<h3 id="X-参数"><a href="#X-参数" class="headerlink" title="X 参数"></a>X 参数</h3><p>在 JVM 各版本中可能会变，变化较小。</p>
<ul>
<li>-Xint：解释执行</li>
<li>-Xcomp：第一次使用就编译成本地代码</li>
<li>-Xmixed：混合模式，JVM 自己来决定是否编译成本地代码</li>
</ul>
<h3 id="XX-参数"><a href="#XX-参数" class="headerlink" title="XX 参数"></a>XX 参数</h3><p>相对不稳定，主要用于 JVM 调优和 Debug。</p>
<p>Boolean 类型：<br>格式：-XX:[+-]<name>，标识启用或者禁用 name 属性。</p>
<p>非 Boolean 类型：<br>格式：-XX:<name>=<value>，表示 name 属性的值是 value。</p>
<ul>
<li><p>-XX:+UserConcMarkSweepGC</p>
</li>
<li><p>-XX:+UseG1GC</p>
</li>
<li><p>-XX:MaxGCPauseMillis</p>
</li>
<li><p>-XX:GCTimeRatio</p>
</li>
<li><p>-Xms：等价于 -XX:InitialHeapSize，表示 JVM 启动时分配的内存。</p>
</li>
<li><p>-Xmx：等价于 -XX:MaxHeapSize，表示 JVM 运行过程中分配的最大内存。</p>
</li>
<li><p>-Xss：等价于 -XX:ThreadStackSize，表示 JVM 启动的每个线程分配的内存大小。</p>
</li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError</p>
</li>
<li><p>-XX:HeapDumpPath</p>
</li>
</ul>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>

<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jstat -class pid</span><br><span class="line"></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line"> 16136 28826.9        1     0.9      36.67</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 17204</span><br><span class="line"></span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">27136.0 20992.0  0.0   20985.8 330240.0 105111.7  139264.0   41337.2   82688.0 77595.2 11776.0 10855.5     19    1.042   3      0.528    1.570</span><br></pre></td></tr></table></figure>

<ul>
<li>S0C、S1C、S0U、S1U：S0 和 S1 的总量与使用量</li>
<li>EC、EU：Eden 区总量与使用量</li>
<li>OC、OU：Old 区总量与使用量</li>
<li>MC、MU：Metaspace 区总量与使用量</li>
<li>CCSC、CCSU：压缩类空间总量与使用量</li>
<li>YGC、YGCT：YoungGC 的次数与时间</li>
<li>FGC、FGCT：FullGC 的次数与实践</li>
<li>GCT：总的 GC 时间</li>
</ul>
<h3 id="JIT-编译"><a href="#JIT-编译" class="headerlink" title="JIT 编译"></a>JIT 编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jstat -compiler 17204</span><br><span class="line"></span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    8432      3       0     4.32          1 org/apache/http/client/utils/URLEncodedUtils parse</span><br></pre></td></tr></table></figure>

<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heap.hprof pid</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure>

<h2 id="jstat-1"><a href="#jstat-1" class="headerlink" title="jstat"></a>jstat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid</span><br></pre></td></tr></table></figure>

<h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><h2 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/%E5%95%86%E5%93%81%E7%A7%92%E6%9D%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/02/%E5%95%86%E5%93%81%E7%A7%92%E6%9D%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">商品秒杀设计与实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-02 19:53:00" itemprop="dateCreated datePublished" datetime="2020-04-02T19:53:00+08:00">2020-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" itemprop="url" rel="index">
                    <span itemprop="name">电商项目实战</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p>超卖</p>
</li>
<li><p>高并发</p>
</li>
<li><p>恶意请求</p>
</li>
</ul>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><ul>
<li><p>行锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> goods <span class="keyword">set</span> inventory = inventory<span class="number">-1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="comment">#&#123;goodsId&#125; and inventory &gt; 0</span></span><br></pre></td></tr></table></figure>
<p>问题：大量锁竞争时，会影响数据库性能。</p>
</li>
<li><p>行锁 + 乐观锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> goods <span class="keyword">set</span> inventory = inventory<span class="number">-1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="comment">#&#123;goodsId&#125; and inventory &gt; 0 and version = #&#123;version&#125;</span></span><br></pre></td></tr></table></figure>
<p>问题：库存 100，且同时只有 100 人抢购商品时，实际卖出的商品可能少于 100。同样存在性能问题</p>
</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li><p>redis 分布式锁<br>问题：不设置锁的过期时间，可能会导致锁一致得不到释放；设置锁的过期时间，又可能因为业务执行时间较长而导致锁提前释放。使用 Lua 脚本或 Redlock 都较为复杂。</p>
</li>
<li><p>ZooKeeper 分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex mutex = <span class="keyword">new</span> InterProcessMutex(zookeeperClient, <span class="string">"/seckill/"</span> + goodsDto.getGoodsId());</span><br><span class="line">mutex.acquire();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 查库存</span></span><br><span class="line">    <span class="comment">// TODO 减库存</span></span><br><span class="line">    <span class="comment">// TODO 下单</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mutex.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="库存预热-amp-内存标记"><a href="#库存预热-amp-内存标记" class="headerlink" title="库存预热 &amp; 内存标记"></a>库存预热 &amp; 内存标记</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;GoodsEntity&gt; goodsList = goodsRepository.findAll();</span><br><span class="line">    goodsList.forEach(goods -&gt; &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(SECKILL_GOODS_KEY_PREFIX + goods.getId(), String.valueOf(goods.getInventory()));</span><br><span class="line">        localGoodsOverMap.put(goods.getId(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取内存标记，判断商品是否售完</span></span><br><span class="line"><span class="keyword">if</span> (localGoodsOverMap.get(goodsId)) &#123;</span><br><span class="line">    log.info(<span class="string">"商品【&#123;&#125;】已售完，抢购失败！"</span>, goodsId);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*** 分布式锁开始 ***</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减 redis 中库存数量，判断商品是否已售完</span></span><br><span class="line">Long inventory = redisTemplate.opsForValue().decrement(SECKILL_GOODS_KEY_PREFIX + goodsDto.getGoodsId());</span><br><span class="line"><span class="keyword">if</span> (inventory == <span class="keyword">null</span> || inventory &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    log.info(<span class="string">"商品【&#123;&#125;】已售完，抢购失败！"</span>, goodsId);</span><br><span class="line">    localGoodsOverMap.put(goodsId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 查库存</span></span><br><span class="line"><span class="comment">// TODO 减库存</span></span><br><span class="line"><span class="comment">// TODO 下单</span></span><br><span class="line"></span><br><span class="line">*** 分布式锁结束 ***</span><br></pre></td></tr></table></figure>

<h3 id="异步下单"><a href="#异步下单" class="headerlink" title="异步下单"></a>异步下单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">OrderEntity order = <span class="keyword">new</span> OrderEntity();</span><br><span class="line">order.setUserId(userId);</span><br><span class="line">order.setGoodsId(goodsId);</span><br><span class="line">order.setStatus(OrderStatus.TO_BE_PAID);</span><br><span class="line">order.setGoodsNum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步下单</span></span><br><span class="line"><span class="comment">// 也可以异步更新库存，这就要求消费者逐个消费消息，不然也会出现并发问题</span></span><br><span class="line">rabbitTemplate.convertAndSend(DIRECT_EXCHANGE, DIRECT_ROUTING_KEY, order);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = DIRECT_QUEUE, concurrency = <span class="string">"10"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(OrderEntity order, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag) </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Receive message by direct-queue: &#123;&#125;"</span>, order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        basicAck(channel, tag);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"创建订单失败【&#123;&#125;】"</span>, order);</span><br><span class="line">        basicNack(channel, tag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">basicAck</span><span class="params">(Channel channel, <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(tag, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"Ack message failure"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝消息确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(Channel channel, <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicNack(tag, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"Nack message failure"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按钮控制"><a href="#按钮控制" class="headerlink" title="按钮控制"></a>按钮控制</h3><p>秒杀开始之前，按钮置灰；用户抢购商品之后，按钮再次置灰。</p>
<h3 id="URL-动态化"><a href="#URL-动态化" class="headerlink" title="URL 动态化"></a>URL 动态化</h3><ol>
<li>在秒杀之前，前端先请求后端获取商品秒杀地址。在后端生成随机数作为 pathId 存入缓存（缓存过期时间 60s），然后将这个随机数返回给前端。</li>
<li>前端获得 pathId 后，将其作为 URL 参数去请求后端秒杀服务。</li>
<li>后端接收 pathId 参数后，将其与缓存中的 pathId 比较。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SeckillGoodsDto <span class="title">createSeckillUrl</span><span class="params">(String goodsId)</span> </span>&#123;</span><br><span class="line">    String randomCode = generateRandomCode(goodsId);</span><br><span class="line">    redisTemplate.opsForValue().set(goodsId, randomCode);</span><br><span class="line"></span><br><span class="line">    SeckillGoodsDto goodsDto = <span class="keyword">new</span> SeckillGoodsDto();</span><br><span class="line">    goodsDto.setGoodsId(goodsId);</span><br><span class="line">    goodsDto.setRandomCode(randomCode);</span><br><span class="line">    <span class="keyword">return</span> goodsDto;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateRandomCode</span><span class="params">(String goodsId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">buyGoods</span><span class="params">(SeckillGoodsDto goodsDto)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验商品 URL 随机码是否一致</span></span><br><span class="line">    <span class="keyword">boolean</span> isValid = validateRandomCode(goodsDto.getGoodsId(), goodsDto.getRandomCode());</span><br><span class="line">    <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validateRandomCode</span><span class="params">(String goodsId, String randomCode)</span> </span>&#123;</span><br><span class="line">    String cachedRandomCode = redisTemplate.opsForValue().get(goodsId);</span><br><span class="line">    <span class="keyword">return</span> randomCode.equals(cachedRandomCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户-IP-限流"><a href="#用户-IP-限流" class="headerlink" title="用户/IP 限流"></a>用户/IP 限流</h3><ul>
<li><p>前端限流<br>秒杀按钮在活动之前置灰，在用户购买之后再次置灰。</p>
</li>
<li><p>后端限流<br>相同用户/IP，设置请求次数限制。如可以基于 Spring Cloud Gateway 添加以下配置：</p>
</li>
</ul>
<p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        # 秒杀服务</span><br><span class="line">        - id: seckill</span><br><span class="line">          uri: lb:&#x2F;&#x2F;seckill</span><br><span class="line">          filters:</span><br><span class="line">            # ip 限流</span><br><span class="line">            - name: RequestRateLimiter</span><br><span class="line">              args:</span><br><span class="line">                # 限流匹配策略</span><br><span class="line">                key-resolver: &#39;#&#123;@ipKeyResolver&#125;&#39;</span><br><span class="line">                # 令牌桶的填充速率：用户每秒执行多少请求</span><br><span class="line">                redis-rate-limiter.replenishRate: 10</span><br><span class="line">                # 令牌桶的容量：用户在一秒钟内执行的最大请求数</span><br><span class="line">                # 将此值设置为零将阻塞所有请求；将此值设置为高于 replenishRate，以允许临时突发</span><br><span class="line">                redis-rate-limiter.burstCapacity: 20</span><br><span class="line">            # 用户限流</span><br><span class="line">            - name: RequestRateLimiter</span><br><span class="line">              args:</span><br><span class="line">                # 限流匹配策略</span><br><span class="line">                key-resolver: &#39;#&#123;@userIdKeyResolver&#125;&#39;</span><br><span class="line">                # 令牌桶的填充速率：用户每秒执行多少请求</span><br><span class="line">                redis-rate-limiter.replenishRate: 10</span><br><span class="line">                # 令牌桶的容量：用户在一秒钟内执行的最大请求数</span><br><span class="line">                # 将此值设置为零将阻塞所有请求；将此值设置为高于 replenishRate，以允许临时突发</span><br><span class="line">                redis-rate-limiter.burstCapacity: 20</span><br></pre></td></tr></table></figure>

<p>ThrottlingConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrottlingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_ID_NAME = <span class="string">"userId"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">apiKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getPath().value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ip 限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">ipKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户限流（未经身份验证直接拒绝请求）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">principalNameKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrincipalNameKeyResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户限流（要求请求路径中必须携带 userId 参数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyResolver <span class="title">userIdKeyResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getQueryParams().getFirst(USER_ID_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="资源静态化"><a href="#资源静态化" class="headerlink" title="资源静态化"></a>资源静态化</h3><ul>
<li><p>JS/CSS 压缩，减少流量</p>
</li>
<li><p>CDN 就近访问</p>
</li>
</ul>
<h3 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h3><ul>
<li><p>降级<br>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。</p>
</li>
<li><p>限流<br>限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。</p>
</li>
<li><p>拒绝服务<br>当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的保护方式。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/Ant%20Design%20Pro%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴天">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OnePiece">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/Ant%20Design%20Pro%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Ant Design Pro 开发实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-17 14:37:00" itemprop="dateCreated datePublished" datetime="2020-03-17T14:37:00+08:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-06 15:11:29" itemprop="dateModified" datetime="2021-05-06T15:11:29+08:00">2021-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="前序准备"><a href="#前序准备" class="headerlink" title="前序准备"></a>前序准备</h3><p>本地环境需要安装 yarn、node 和 git。我们的技术栈基于 ES2015+、React、UmiJS、dva、g2 和 antd，提前了解和学习这些知识会非常有帮助。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>新建一个空的文件夹作为项目目录，并在目录下执行：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yarn</span> <span class="string">create</span> <span class="string">umi</span></span><br></pre></td></tr></table></figure>

<p>选择 ant-design-pro：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Select the boilerplate <span class="built_in">type</span> (Use arrow keys)</span><br><span class="line">❯ ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.</span><br><span class="line">  app             - Create project with a simple boilerplate, support typescript.</span><br><span class="line">  block           - Create a umi block.</span><br><span class="line">  library         - Create a library with umi.</span><br><span class="line">  plugin          - Create a umi plugin.</span><br></pre></td></tr></table></figure>

<p>Ant Design Pro 脚手架将会自动安装。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>Ant Design Pro 已经为我们生成了一个完整的开发框架，提供了涵盖中后台开发的各类功能和坑位，下面是整个项目的目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── config                   # umi 配置，包含路由，构建等配置</span><br><span class="line">├── mock                     # 本地模拟数据</span><br><span class="line">├── public</span><br><span class="line">│   └── favicon.png          # Favicon</span><br><span class="line">├── src</span><br><span class="line">│   ├── assets               # 本地静态资源</span><br><span class="line">│   ├── components           # 业务通用组件</span><br><span class="line">│   ├── e2e                  # 集成测试用例</span><br><span class="line">│   ├── layouts              # 通用布局</span><br><span class="line">│   ├── models               # 全局 dva model</span><br><span class="line">│   ├── pages                # 业务页面入口和常用模板</span><br><span class="line">│   ├── services             # 后台接口服务</span><br><span class="line">│   ├── utils                # 工具库</span><br><span class="line">│   ├── locales              # 国际化资源</span><br><span class="line">│   ├── global.less          # 全局样式</span><br><span class="line">│   └── global.tsx           # 全局 JS</span><br><span class="line">├── tests                    # 测试工具</span><br><span class="line">├── README.md</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<h3 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h3><p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure>

<p>启动完成后会自动打开浏览器访问 localhost:8000，看到下面的页面就代表成功了。</p>
<p><img src="../images/react/Ant%20Design%20Pro%E9%A2%84%E8%A7%88.png" alt="Ant Design Pro预览"></p>
<p>接下来我们可以修改代码进行业务开发了，Ant Design Pro 内建了模拟数据、HMR 实时预览、状态管理、国际化、全局路由等等各种实用的功能辅助开发，我们可以继续阅读和探索其他文档。</p>
<h2 id="个性化调整"><a href="#个性化调整" class="headerlink" title="个性化调整"></a>个性化调整</h2><h3 id="更换地址栏-logo和标题"><a href="#更换地址栏-logo和标题" class="headerlink" title="更换地址栏 logo和标题"></a>更换地址栏 logo和标题</h3><p>更改 logo：<br>该 logo 位于 /public/favicon.svg，可以用其它 logo 将其替换掉，或者修改 /src/pages/document.ejs 中的 link 元素的 href 属性。</p>
<p>更换标题：<br>修改 /src/pages/document.ejs 中的 title 内容。</p>
<h3 id="更换主页-logo-和标题"><a href="#更换主页-logo-和标题" class="headerlink" title="更换主页 logo 和标题"></a>更换主页 logo 和标题</h3><p>更换 logo：<br>该 logo 位于 /src/assets/logo.svg，可以用其它 logo 将其替换掉，或者修改 BasicLayout.tsx 中的 ProLayout 组件的 logo 属性。</p>
<p>更换标题：<br>修改 /config/defaultSetting.ts 中的 title 属性。</p>
<h3 id="更换启动时-logo-和标题"><a href="#更换启动时-logo-和标题" class="headerlink" title="更换启动时 logo 和标题"></a>更换启动时 logo 和标题</h3><p>修改 /src/pages/document.ejs 中第 2 个 img 元素的 src 属性和紧跟 img 后的内容。</p>
<h3 id="更换首页刷新时-logo"><a href="#更换首页刷新时-logo" class="headerlink" title="更换首页刷新时 logo"></a>更换首页刷新时 logo</h3><p>该 logo 位于 /public/pro_icon.svg，可以用其它 logo 将其替换掉，或者修改 /src/pages/document.ejs 中的第 1 个 img 元素的 src 属性。</p>
<h3 id="修改页脚内容"><a href="#修改页脚内容" class="headerlink" title="修改页脚内容"></a>修改页脚内容</h3><p>修改 /src/layouts/BasicLayout.tsx 中的 DefaultFooter 组件的 copyright 和 links 属性。</p>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Ant Design Pro 默认提供了 dark(默认) 和 light 这两种主题，可以通过修改 /config/defaultSetting.js 中的 navTheme 属性来更换主题。</p>
<h3 id="更换导航模式"><a href="#更换导航模式" class="headerlink" title="更换导航模式"></a>更换导航模式</h3><p>Ant Design Pro 同时支持侧边栏和顶部栏显示导航，可以通过修改 /config/defaultSetting.js 中的 layout 属性来更换导航模式。</p>
<h3 id="移除头部不必要的小组件"><a href="#移除头部不必要的小组件" class="headerlink" title="移除头部不必要的小组件"></a>移除头部不必要的小组件</h3><p>在实际开发过程中，我们的项目可能不需要 “全局搜索”、”使用文档” 、”国际化切换”这些组件，可以到 /src/components/GlobalHeader/RightContent.js 中注释掉 HeaderSearch、Tooltipown、SelectLang 这几个组件的使用。</p>
<h3 id="显示个人中心-设置菜单"><a href="#显示个人中心-设置菜单" class="headerlink" title="显示个人中心/设置菜单"></a>显示个人中心/设置菜单</h3><p>在 /src/components/GlobalHeader/RightContent.tsx 中引用 AvatarDropdown 组件的地方添加 menu 属性。</p>
<h3 id="显示通知-消息-代办"><a href="#显示通知-消息-代办" class="headerlink" title="显示通知/消息/代办"></a>显示通知/消息/代办</h3><p>在 /src/components/GlobalHeader/RightContent.js 中引入并使用 NoticeIconView 组件。</p>
<h3 id="调整用户登录页"><a href="#调整用户登录页" class="headerlink" title="调整用户登录页"></a>调整用户登录页</h3><p>对于用户登录页的 logo、标题、描述、登录方式、页脚和国际化支持，也可以到 /src/layouts/UserLayout.tsx 中做相应调整。</p>
<h3 id="不显示页面-title"><a href="#不显示页面-title" class="headerlink" title="不显示页面 title"></a>不显示页面 title</h3><p>每个页面都由 PageHeaderWrapper 封装，PageHeaderWrapper 默认会显示页面 title，但是 title 已经在面包屑中显示了，因此可以隐藏掉 PageHeaderWrapper 中的 title，具体做法是给其传递 title = false。</p>
<h3 id="未登录跳转到登录页"><a href="#未登录跳转到登录页" class="headerlink" title="未登录跳转到登录页"></a>未登录跳转到登录页</h3><p>默认情况下，用户未登录也会跳转到欢迎页，如果要实现未登录时跳转到登录页，只需在 /config/config.js 中的 routes 列表里的 ../layouts/SecurityLayout 那一项中添加 Routes: [‘src/pages/Authorized’]。<br>还有一点需要注意，默认在用户退出登录后，Ant Design Pro 并没有清理掉用户权限信息，我们需要在 /src/models/login.ts 的 logout 方法中添加 localStorage.removeItem(‘antd-pro-authority’) 。</p>
<h3 id="不启动-Umi-UI"><a href="#不启动-Umi-UI" class="headerlink" title="不启动 Umi UI"></a>不启动 Umi UI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start:no-ui</span><br></pre></td></tr></table></figure>

<h3 id="关闭-Mock-数据"><a href="#关闭-Mock-数据" class="headerlink" title="关闭 Mock 数据"></a>关闭 Mock 数据</h3><ol>
<li>启动命令改为：<code>yarn start:no-mock</code>。</li>
<li>修改 /config/proxy.ts：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">dev: &#123;</span><br><span class="line">    &#39;&#x2F;api&#x2F;&#39;: &#123;</span><br><span class="line">      target: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;&#39;,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite: &#123;&#39;^&#x2F;api&#x2F;&#39;: &#39;&#39;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意：查看控制台，会发现请求的地址还是 localhost:8000/，但实际上已经请求到后端地址了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">晴天</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">晴天</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
